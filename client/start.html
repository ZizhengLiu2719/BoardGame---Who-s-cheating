<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Who's Cheating? ‚Äì Game Room</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="style.css">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Gochi+Hand&display=swap');
    body {
      margin: 0; padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #1a1a2e;
      color: #e2e2e2;
      min-height: 100vh;
      transition: background 0.5s ease;
      overflow-x: hidden;
    }
    body.day-mode {
      background: linear-gradient(135deg, #f8f4e3 0%, #e8d5b5 50%, #ffe7b2 100%);
      color: #2c2c2c;
    }
    body.night-mode {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f1419 100%);
    }

    /* Ghibli-inspired background elements */
    /* Starfield */
    .ghibli-stars {
      position: fixed;
      left: 0; top: 0; width: 100vw; height: 100vh;
      pointer-events: none;
      z-index: 0;
      background: transparent;
      transition: opacity 0.5s ease;
    }
    .ghibli-stars span {
      position: absolute;
      display: block;
      border-radius: 50%;
      background: #fffbe7;
      opacity: 0.7;
      filter: blur(0.5px);
      animation: twinkle 3.5s infinite alternate;
    }
    body.day-mode .ghibli-stars span {
      background: rgba(255, 220, 168, 0.6);
      opacity: 0.4;
      box-shadow: 0 0 4px rgba(255, 220, 168, 0.4);
    }
    @keyframes twinkle {
      0%,100% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 0.3; transform: scale(0.8); }
    }

    /* Crescent moon */
    .ghibli-moon {
      position: fixed;
      right: 5vw;
      top: 4vw;
      width: 80px;
      height: 80px;
      z-index: 1;
      opacity: 0.25;
      pointer-events: none;
      filter: drop-shadow(0 0 12px rgba(255, 251, 231, 0.4));
      transition: opacity 0.8s ease;
      animation: moon-glow 4s ease-in-out infinite alternate;
    }
    @keyframes moon-glow {
      0% { filter: drop-shadow(0 0 12px rgba(255, 251, 231, 0.4)); }
      100% { filter: drop-shadow(0 0 20px rgba(255, 251, 231, 0.6)); }
    }
    body.day-mode .ghibli-moon {
      opacity: 0.05;
      filter: drop-shadow(0 0 4px rgba(255, 251, 231, 0.1));
    }

    /* Moonlight reflection */
    .moonlight-reflection {
      position: fixed;
      right: 0;
      top: 0;
      width: 250px;
      height: 100vh;
      background: linear-gradient(90deg, 
        rgba(255, 251, 231, 0.08) 0%, 
        rgba(255, 251, 231, 0.04) 50%, 
        transparent 100%);
      pointer-events: none;
      z-index: 1;
      animation: moonlight-shimmer 10s ease-in-out infinite alternate;
      transition: opacity 0.8s ease;
    }
    body.day-mode .moonlight-reflection {
      background: linear-gradient(90deg, 
        rgba(255, 220, 168, 0.04) 0%, 
        rgba(255, 220, 168, 0.02) 50%, 
        transparent 100%);
    }
    @keyframes moonlight-shimmer {
      0% { opacity: 0.4; transform: translateX(0px); }
      100% { opacity: 0.8; transform: translateX(-15px); }
    }

    /* Floating particles */
    .floating-particles {
      position: fixed;
      left: 0; top: 0; width: 100vw; height: 100vh;
      pointer-events: none;
      z-index: 1;
      transition: opacity 0.8s ease;
    }
    .particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: rgba(255, 251, 231, 0.6);
      border-radius: 50%;
      animation: float-particle 25s linear infinite;
      box-shadow: 0 0 6px rgba(255, 251, 231, 0.4);
    }
    body.day-mode .particle {
      background: rgba(255, 220, 168, 0.4);
      box-shadow: 0 0 4px rgba(255, 220, 168, 0.3);
    }
    @keyframes float-particle {
      0% { 
        transform: translateY(100vh) translateX(0px) rotate(0deg);
        opacity: 0;
      }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { 
        transform: translateY(-100px) translateX(120px) rotate(360deg);
        opacity: 0;
      }
    }

    /* Soft vignette overlay */
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      z-index: 0;
      pointer-events: none;
      background: radial-gradient(ellipse at 50% 60%, 
        rgba(30,20,40,0) 60%, 
        rgba(30,20,40,0.85) 100%);
      transition: opacity 0.5s;
    }
    body.day-mode::before {
      background: radial-gradient(ellipse at 50% 60%, 
        rgba(248,244,227,0) 60%, 
        rgba(248,244,227,0.3) 100%);
    }

    .container {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      align-items: flex-start;
      min-height: 100vh;
      width: 100vw;
      box-sizing: border-box;
      padding: 32px 0 32px 0;
      z-index: 1;
    }
    .left-panel, .right-panel {
      width: 320px;
      min-width: 260px;
      max-width: 400px;
      margin: 0 24px;
      display: flex;
      flex-direction: column;
      gap: 32px;
      background: rgba(255,251,231,0.92);
      border-radius: 24px;
      box-shadow: 
        0 4px 32px 0 #23202a33, 
        0 2px 0 #fffbe7 inset,
        0 0 20px rgba(226, 195, 145, 0.2);
      border: 2.5px solid #bfa16a;
      padding: 18px 18px 18px 18px;
      backdrop-filter: blur(10px);
      position: relative;
      overflow: hidden;
    }
    .left-panel::before, .right-panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #e2c391, #bfa16a, #e2c391);
      border-radius: 24px 24px 0 0;
    }
    .center-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-width: 400px;
      max-width: 900px;
      z-index: 2;
    }
    .title-badge {
      font-size: 2.3rem;
      font-family: 'Gochi Hand', 'Caveat', 'Segoe Print', cursive;
      font-weight: bold;
      background: linear-gradient(120deg,#23202a 60%,#6b5a3a 100%);
      color: #e2c391;
      border-radius: 32px 22px 38px 22px/22px 38px 22px 38px;
      border: 3.5px solid #7bb0e6;
      box-shadow: 
        0 6px 24px 0 #23202a55, 
        0 2px 0 #fffbe7 inset,
        0 0 20px rgba(123, 176, 230, 0.3);
      padding: 22px 48px 18px 48px;
      margin-bottom: 18px;
      text-align: center;
      letter-spacing: 2px;
      min-width: 200px;
      transition: all 0.3s;
      text-shadow: 0 2px 8px #23202a44;
      position: relative;
    }
    .title-badge::after {
      content: '';
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      height: 4px;
      background: linear-gradient(90deg, transparent, #e2c391, transparent);
      border-radius: 2px;
    }
    body.day-mode .title-badge {
      background: linear-gradient(120deg,#fffbe7 60%,#ffe7b2 100%);
      color: #e2a84f;
      border: 3.5px solid #ffdca8;
      box-shadow: 
        0 6px 24px 0 #ffdca855, 
        0 2px 0 #fffbe7 inset,
        0 0 20px rgba(255, 220, 168, 0.3);
    }
    .score-box, .love-hate-box {
      background: #fffbe7ee;
      border-radius: 18px;
      box-shadow: 
        0 2px 18px 0 #23202a22,
        0 2px 0 #fffbe7 inset,
        0 0 15px rgba(226, 195, 145, 0.1);
      border: 2px solid #7bb0e6;
      padding: 18px 18px 14px 18px;
      font-size: 1.13rem;
      color: #7a5a2f;
      margin-bottom: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      font-family: 'Gochi Hand', 'Segoe Print', cursive;
      position: relative;
      overflow: hidden;
    }
    .score-box::before, .love-hate-box::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, #7bb0e6, #e2c391, #7bb0e6);
      border-radius: 18px 18px 0 0;
    }
    body.day-mode .score-box, body.day-mode .love-hate-box {
      border: 2px solid #ffdca8;
      box-shadow: 
        0 2px 18px 0 #ffdca822,
        0 2px 0 #fffbe7 inset,
        0 0 15px rgba(255, 220, 168, 0.1);
    }
    body.day-mode .score-box::before, body.day-mode .love-hate-box::before {
      background: linear-gradient(90deg, #ffdca8, #e2c391, #ffdca8);
    }
    .score-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .score-label {
      flex: 1;
      font-weight: bold;
      font-size: 1.13em;
      letter-spacing: 1px;
    }
    .score-controls {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .score-btn {
      width: 36px; height: 36px;
      border-radius: 12px;
      border: 2.5px solid #e2c391;
      background: linear-gradient(120deg,#ffe7b2 60%,#bfa16a 100%);
      color: #7a5a2f;
      font-size: 1.3em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 
        0 2px 8px #bfa16a33,
        0 0 0 1px rgba(255, 255, 255, 0.1) inset;
    }
    .score-btn:hover {
      transform: translateY(-2px);
      box-shadow: 
        0 4px 12px #bfa16a55,
        0 0 0 1px rgba(255, 255, 255, 0.2) inset;
    }
    .score-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .score-value {
      width: 36px;
      text-align: center;
      font-size: 1.18em;
      font-weight: bold;
      color: #bfa16a;
      background: #fffbe7cc;
      border-radius: 8px;
      border: 1.5px solid #e2c391;
      box-shadow: 0 1px 4px #bfa16a22 inset;
    }
    .action-btn, .reset-btn, .vote-btn, .skill-btn {
      width: 100%;
      margin-top: 8px;
      padding: 12px 0;
      border-radius: 16px;
      border: 2.5px solid #e2c391;
      background: linear-gradient(120deg,#ffe7b2 60%,#bfa16a 100%);
      color: #7a5a2f;
      font-size: 1.18em;
      font-family: 'Gochi Hand', 'Segoe Print', cursive;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 
        0 2px 8px #bfa16a33,
        0 0 0 1px rgba(255, 255, 255, 0.1) inset;
      letter-spacing: 1px;
      text-shadow: 0 1px 4px #fffbe7cc;
      position: relative;
      overflow: hidden;
    }
    .action-btn::before, .reset-btn::before, .vote-btn::before, .skill-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }
    .action-btn:hover::before, .reset-btn:hover::before, .vote-btn:hover::before, .skill-btn:hover::before {
      left: 100%;
    }
    .action-btn:hover, .reset-btn:hover, .vote-btn:hover, .skill-btn:hover {
      transform: translateY(-2px);
      box-shadow: 
        0 4px 12px #bfa16a55,
        0 0 0 1px rgba(255, 255, 255, 0.2) inset;
    }
    .action-btn:disabled, .reset-btn:disabled, .vote-btn:disabled, .skill-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .love-hate-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
    }
    .love-hate-label {
      flex: 1;
      font-weight: bold;
      font-size: 1.13em;
    }
    .love-hate-value {
      width: 36px;
      text-align: center;
      font-size: 1.18em;
      font-weight: bold;
      color: #e26a6a;
      background: #fffbe7cc;
      border-radius: 8px;
      border: 1.5px solid #e2c391;
      box-shadow: 0 1px 4px #e2c39122 inset;
    }
    .hate-value {
      color: #7a5a2f;
    }
    .circle-table-container {
      position: relative;
      width: 520px;
      height: 520px;
      margin: 0 auto 24px auto;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
    }
    .circle-table {
      width: 420px;
      height: 420px;
      border-radius: 50%;
      background: radial-gradient(circle at 60% 40%, #6b5a3a 55%, #2d1c0b 100%);
      border: 10px solid #bfa16a;
      box-shadow: 
        0 16px 64px 0 #23202a, 
        0 0 0 32px #23202a33 inset, 
        0 0 0 12px #7bb0e633 inset,
        0 0 40px rgba(123, 176, 230, 0.2);
      position: absolute;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      z-index: 1;
      transition: all 0.3s ease;
    }
    body.day-mode .circle-table {
      background: radial-gradient(circle at 60% 40%, #fffbe7 60%, #ffe7b2 100%);
      box-shadow: 
        0 20px 80px 0 #ffdca888, 
        0 0 0 32px #fffbe7cc inset, 
        0 0 0 12px #ffe7b2cc inset,
        0 0 40px rgba(255, 220, 168, 0.3);
    }

    /* Enhanced table details */
    .table-details {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 200px;
      height: 200px;
      z-index: 2;
      pointer-events: none;
    }
    .table-center-decoration {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, #e2c391 30%, #bfa16a 70%);
      border-radius: 50%;
      border: 2px solid #7a5a2f;
      box-shadow: 
        0 0 20px rgba(226, 195, 145, 0.4),
        inset 0 0 20px rgba(255, 255, 255, 0.1);
    }
    .table-pattern {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 300px;
      height: 300px;
      border: 1px solid rgba(226, 195, 145, 0.3);
      border-radius: 50%;
    }
    .table-pattern::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 250px;
      height: 250px;
      border: 1px solid rgba(226, 195, 145, 0.2);
      border-radius: 50%;
    }
    .table-pattern::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 200px;
      height: 200px;
      border: 1px solid rgba(226, 195, 145, 0.1);
      border-radius: 50%;
    }

    /* Table cups */
    .table-cups {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 400px;
      height: 400px;
      z-index: 3;
      pointer-events: none;
    }
    .cup {
      position: absolute;
      width: 24px;
      height: 32px;
      background: linear-gradient(135deg, #fffbe7 0%, #ffe7b2 50%, #e2c391 100%);
      border-radius: 12px 12px 8px 8px / 16px 16px 12px 12px;
      border: 2px solid #bfa16a;
      box-shadow: 
        0 2px 8px rgba(0, 0, 0, 0.2),
        inset 0 2px 4px rgba(255, 255, 255, 0.3);
    }
    .cup::before {
      content: '';
      position: absolute;
      top: 4px;
      left: 50%;
      transform: translateX(-50%);
      width: 16px;
      height: 20px;
      background: linear-gradient(135deg, #cbe6d6 0%, #a0bfa1 100%);
      border-radius: 8px 8px 6px 6px / 10px 10px 8px 8px;
      border: 1px solid #7a9a7b;
    }
    .cup::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 50%;
      transform: translateX(-50%);
      width: 20px;
      height: 4px;
      background: #bfa16a;
      border-radius: 2px;
    }

    /* Enhanced day mode sunny effects */
    .sunny-effects {
      position: fixed;
      left: 0; top: 0; width: 100vw; height: 100vh;
      pointer-events: none;
      z-index: 1;
      opacity: 0;
      transition: opacity 0.8s ease;
    }
    body.day-mode .sunny-effects {
      opacity: 1;
    }

    /* Enhanced sun rays for happy party vibe */
    .sun-rays {
      position: absolute;
      right: 8vw;
      top: 6vw;
      width: 100px;
      height: 100px;
      z-index: 2;
    }
    .sun-rays::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80px;
      height: 80px;
      background: radial-gradient(circle, #ffdca8 0%, #ffe7b2 60%, #fff5e6 100%);
      border-radius: 50%;
      box-shadow: 
        0 0 30px rgba(255, 220, 168, 0.8),
        0 0 60px rgba(255, 220, 168, 0.4);
      animation: sun-pulse 3s ease-in-out infinite alternate;
    }
    @keyframes sun-pulse {
      0% { transform: translate(-50%, -50%) scale(1); }
      100% { transform: translate(-50%, -50%) scale(1.1); }
    }
    .sun-ray {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 6px;
      height: 25px;
      background: linear-gradient(to bottom, #ffdca8, transparent);
      border-radius: 3px;
      transform-origin: 3px 12.5px;
      animation: sun-rotate 20s linear infinite;
      box-shadow: 0 0 8px rgba(255, 220, 168, 0.6);
    }
    @keyframes sun-rotate {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    /* Enhanced floating flowers for happy party vibe */
    .floating-flowers {
      position: fixed;
      left: 0; top: 0; width: 100vw; height: 100vh;
      pointer-events: none;
      z-index: 1;
      opacity: 0;
      transition: opacity 0.8s ease;
    }
    body.day-mode .floating-flowers {
      opacity: 1;
    }
    .flower {
      position: absolute;
      width: 24px;
      height: 24px;
      animation: float-flower 18s linear infinite;
      opacity: 0.8;
    }
    .flower::before {
      content: 'üå∏';
      font-size: 24px;
      filter: drop-shadow(0 3px 6px rgba(255, 182, 193, 0.4));
      animation: flower-bounce 2s ease-in-out infinite alternate;
    }
    @keyframes flower-bounce {
      0% { transform: scale(1) rotate(0deg); }
      100% { transform: scale(1.1) rotate(5deg); }
    }
    @keyframes float-flower {
      0% { 
        transform: translateY(100vh) translateX(0px) rotate(0deg);
        opacity: 0;
      }
      10% { opacity: 0.8; }
      90% { opacity: 0.8; }
      100% { 
        transform: translateY(-100px) translateX(80px) rotate(360deg);
        opacity: 0;
      }
    }

    /* Enhanced night mode elements for night vibe */
    .ghibli-stars {
      position: fixed;
      left: 0; top: 0; width: 100vw; height: 100vh;
      pointer-events: none;
      z-index: 0;
      background: transparent;
      transition: opacity 0.8s ease;
    }
    .ghibli-stars span {
      position: absolute;
      display: block;
      border-radius: 50%;
      background: #fffbe7;
      opacity: 0.8;
      filter: blur(0.5px);
      animation: twinkle 4s infinite alternate;
      box-shadow: 0 0 6px rgba(255, 251, 231, 0.6);
    }
    body.day-mode .ghibli-stars span {
      object-fit: cover;
      transition: all 0.3s ease;
      cursor: pointer;
    }
    .role-card:hover {
      transform: scale(1.05) translateY(-4px);
      box-shadow: 
        0 12px 36px rgba(0, 0, 0, 0.2),
        0 0 0 2px rgba(226, 195, 145, 0.3) inset;
    }
    .role-card.me {
      border: 3px solid #7a5a2f;
      box-shadow: 
        0 0 0 4px rgba(191, 161, 106, 0.3),
        0 6px 24px rgba(0, 0, 0, 0.15),
        0 0 0 1px rgba(255, 255, 255, 0.1) inset;
    }
    .role-card.me.night-mode {
      border-color: #7bb0e6;
      box-shadow: 
        0 0 0 4px rgba(123, 176, 230, 0.3),
        0 6px 24px rgba(0, 0, 0, 0.15),
        0 0 0 1px rgba(255, 255, 255, 0.1) inset;
    }

    /* Enhanced player name labels */
    .player-name-label {
      position: absolute;
      padding: 6px 12px;
      background: rgba(40, 30, 20, 0.85);
      color: #e2c391;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 500;
      white-space: nowrap;
      pointer-events: none;
      transition: all 0.3s ease;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(226, 195, 145, 0.3);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }
    .player-name-label.night-mode {
      background: rgba(26, 26, 46, 0.85);
      color: #7bb0e6;
      border: 1px solid rgba(123, 176, 230, 0.3);
    }

    /* Enhanced skill buttons */
    .skill-btn {
      width: auto;
      min-width: 120px;
      margin: 0 8px;
      padding: 10px 18px;
      border-radius: 14px;
      border: 2.5px solid #e2c391;
      background: linear-gradient(120deg,#ffe7b2 60%,#bfa16a 100%);
      color: #7a5a2f;
      font-size: 1.13em;
      font-family: 'Gochi Hand', 'Segoe Print', cursive;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.2s, color 0.2s, box-shadow 0.2s;
      box-shadow: 0 2px 8px #bfa16a33;
      letter-spacing: 1px;
      text-shadow: 0 1px 4px #fffbe7cc;
    }
    .skill-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Enhanced vote buttons */
    #voteYesBtn, #voteNoBtn, #voteSubmitBtn {
      background: linear-gradient(120deg, #ffe7b2 60%, #bfa16a 100%) !important;
      border: 2.5px solid #e2c391 !important;
      border-radius: 16px !important;
      color: #7a5a2f !important;
      font-weight: bold !important;
      box-shadow: 
        0 2px 8px #bfa16a33,
        0 0 0 1px rgba(255, 255, 255, 0.1) inset !important;
      transition: all 0.2s !important;
      font-family: 'Gochi Hand', 'Segoe Print', cursive !important;
      position: relative;
      overflow: hidden;
    }
    #voteYesBtn::before, #voteNoBtn::before, #voteSubmitBtn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }
    #voteYesBtn:hover::before, #voteNoBtn:hover::before, #voteSubmitBtn:hover::before {
      left: 100%;
    }
    #voteYesBtn:hover, #voteNoBtn:hover, #voteSubmitBtn:hover {
      transform: translateY(-2px) !important;
      box-shadow: 
        0 4px 12px #bfa16a55,
        0 0 0 1px rgba(255, 255, 255, 0.2) inset !important;
    }
    #voteYesBtn:disabled, #voteNoBtn:disabled, #voteSubmitBtn:disabled {
      opacity: 0.5 !important;
      cursor: not-allowed !important;
      transform: none !important;
    }

    /* Enhanced score values */
    .score-value {
      width: 36px;
      text-align: center;
      font-size: 1.18em;
      font-weight: bold;
      color: #bfa16a;
      background: linear-gradient(135deg, #fffbe7 0%, #ffe7b2 100%);
      border-radius: 8px;
      border: 1.5px solid #e2c391;
      box-shadow: 
        0 1px 4px #bfa16a22 inset,
        0 0 0 1px rgba(255, 255, 255, 0.1) inset;
      transition: all 0.2s;
    }
    .score-value:hover {
      transform: scale(1.05);
      box-shadow: 
        0 2px 6px #bfa16a33 inset,
        0 0 0 1px rgba(255, 255, 255, 0.2) inset;
    }

    /* Enhanced love/hate values */
    .love-hate-value {
      width: 36px;
      text-align: center;
      font-size: 1.18em;
      font-weight: bold;
      color: #e26a6a;
      background: linear-gradient(135deg, #fffbe7 0%, #ffe7b2 100%);
      border-radius: 8px;
      border: 1.5px solid #e2c391;
      box-shadow: 
        0 1px 4px #e2c39122 inset,
        0 0 0 1px rgba(255, 255, 255, 0.1) inset;
      transition: all 0.2s;
    }
    .love-hate-value:hover {
      transform: scale(1.05);
      box-shadow: 
        0 2px 6px #e2c39133 inset,
        0 0 0 1px rgba(255, 255, 255, 0.2) inset;
    }
    .hate-value {
      color: #7a5a2f;
    }

    /* Enhanced scrollbar styling for How to Play box */
    .score-box::-webkit-scrollbar {
      width: 8px;
    }
    .score-box::-webkit-scrollbar-track {
      background: rgba(226, 195, 145, 0.1);
      border-radius: 4px;
    }
    .score-box::-webkit-scrollbar-thumb {
      background: linear-gradient(135deg, #e2c391 0%, #bfa16a 100%);
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .score-box::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(135deg, #bfa16a 0%, #7a5a2f 100%);
    }
    body.day-mode .score-box::-webkit-scrollbar-thumb {
      background: linear-gradient(135deg, #ffdca8 0%, #e2c391 100%);
    }
    body.day-mode .score-box::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(135deg, #e2c391 0%, #bfa16a 100%);
    }

    /* Enhanced toggle button with dynamic styling */
    #toggleStageBtn {
      position: fixed;
      top: 32px;
      right: 32px;
      padding: 12px 28px;
      font-size: 1.1em;
      border-radius: 16px;
      border: 2px solid #e2c391;
      background: linear-gradient(120deg, #ffe7b2 60%, #bfa16a 100%);
      color: #7a5a2f;
      font-weight: bold;
      box-shadow: 
        0 2px 8px 0 #e2c39133,
        0 0 0 1px rgba(255, 255, 255, 0.1) inset;
      cursor: pointer;
      z-index: 1000;
      transition: all 0.3s ease;
      font-family: 'Gochi Hand', 'Segoe Print', cursive;
      letter-spacing: 1px;
      text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
      position: relative;
      overflow: hidden;
    }
    #toggleStageBtn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: left 0.6s;
    }
    #toggleStageBtn:hover::before {
      left: 100%;
    }
    #toggleStageBtn:hover {
      transform: translateY(-3px);
      box-shadow: 
        0 8px 20px 0 #e2c39166,
        0 0 0 1px rgba(255, 255, 255, 0.2) inset,
        0 0 30px rgba(226, 195, 145, 0.4);
    }
    #toggleStageBtn:active {
      transform: translateY(-1px);
    }

    /* Day mode button styling */
    body.day-mode #toggleStageBtn {
      border: 2px solid #ffdca8;
      background: linear-gradient(120deg, #fffbe7 60%, #ffe7b2 100%);
      color: #e2a84f;
      box-shadow: 
        0 2px 8px 0 #ffdca833,
        0 0 0 1px rgba(255, 255, 255, 0.1) inset;
    }
    body.day-mode #toggleStageBtn:hover {
      box-shadow: 
        0 8px 20px 0 #ffdca866,
        0 0 0 1px rgba(255, 255, 255, 0.2) inset,
        0 0 30px rgba(255, 220, 168, 0.4);
    }

    /* Night mode button styling */
    body.night-mode #toggleStageBtn {
      border: 2px solid #7bb0e6;
      background: linear-gradient(120deg, #23202a 60%, #22304a 100%);
      color: #7bb0e6;
      box-shadow: 
        0 2px 8px 0 #23202a99,
        0 0 0 1px rgba(255, 255, 255, 0.05) inset;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
    }
    body.night-mode #toggleStageBtn:hover {
      box-shadow: 
        0 8px 20px 0 #23202acc,
        0 0 0 1px rgba(255, 255, 255, 0.1) inset,
        0 0 30px rgba(123, 176, 230, 0.4);
    }

    /* Update role card CSS size */
    .role-card {
      width: 68px !important;
      height: 96px !important;
    }

    .floating-happy-emojis {
      position: fixed;
      left: 0; top: 0; width: 100vw; height: 100vh;
      pointer-events: none;
      z-index: 1;
      opacity: 0;
      transition: opacity 0.8s ease;
    }
    body.day-mode .floating-happy-emojis {
      opacity: 1;
    }
    .happy-emoji {
      position: absolute;
      width: 32px;
      height: 32px;
      font-size: 32px;
      animation: float-happy-emoji 20s linear infinite;
      opacity: 0.85;
      filter: drop-shadow(0 3px 6px rgba(255, 220, 168, 0.3));
      user-select: none;
    }
    @keyframes float-happy-emoji {
      0% {
        transform: translateY(100vh) scale(1) rotate(0deg);
        opacity: 0;
      }
      10% { opacity: 0.85; }
      90% { opacity: 0.85; }
      100% {
        transform: translateY(-100px) scale(1.1) rotate(360deg);
        opacity: 0;
      }
    }
    .role-cards-circle { z-index: 10 !important; }
    .role-card { z-index: 11 !important; }

    .voice-chat-status-box {
      position: fixed;
      bottom: 32px;
      right: 32px;
      z-index: 1200;
      background: linear-gradient(120deg, #fffbe7 60%, #ffe7b2 100%);
      color: #7a5a2f;
      border: 2.5px solid #ffdca8;
      border-radius: 18px;
      box-shadow: 0 8px 32px 0 #ffdca855, 0 2px 0 #fffbe7 inset;
      font-family: 'Gochi Hand', 'Segoe Print', cursive;
      font-size: 1.13em;
      font-weight: bold;
      padding: 18px 32px 18px 32px;
      min-width: 220px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 10px;
      transition: all 0.3s;
    }
    .voice-chat-status-title {
      font-size: 1.18em;
      color: #e2a84f;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .voice-chat-status-title .emoji {
      font-size: 1.3em;
    }
    .voice-chat-participant {
      font-size: 1.05em;
      color: #7a5a2f;
      margin-bottom: 2px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .voice-mute-toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: linear-gradient(120deg, #ffe7b2 60%, #bfa16a 100%);
      border: 2px solid #e2c391;
      border-radius: 12px;
      color: #7a5a2f;
      font-size: 1.08em;
      font-family: 'Gochi Hand', 'Segoe Print', cursive;
      font-weight: bold;
      padding: 6px 18px;
      cursor: pointer;
      box-shadow: 0 2px 8px #bfa16a33;
      transition: all 0.2s;
      margin-top: 6px;
      margin-bottom: 2px;
      outline: none;
      position: relative;
    }
    .voice-mute-toggle:hover {
      background: linear-gradient(120deg, #fffbe7 60%, #ffe7b2 100%);
      color: #e2a84f;
      box-shadow: 0 8px 20px 0 #ffdca866, 0 0 0 1px rgba(255,255,255,0.2) inset, 0 0 30px rgba(255,220,168,0.4);
      transform: translateY(-2px) scale(1.04);
    }
    .voice-mute-toggle.muted {
      background: linear-gradient(120deg, #e2c391 60%, #ffdca8 100%);
      color: #bfa16a;
    }
    .voice-mute-toggle .emoji {
      font-size: 1.2em;
      margin-right: 4px;
    }

    /* Add CSS for host helper mode */
    .host-helper-mode .player-card {
      cursor: pointer;
      transition: transform 0.3s, box-shadow 0.3s;
    }
    .host-helper-mode .player-card:hover {
      transform: scale(1.05);
      box-shadow: 0 0 20px rgba(226, 195, 145, 0.4);
    }
    .player-card.selected-host {
      border: 4px solid #4caf50;
      box-shadow: 0 0 20px rgba(76, 175, 80, 0.4);
    }
    .ghibli-notification {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #fffbe7;
      border: 2px solid #e2c391;
      border-radius: 12px;
      padding: 15px 25px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      font-family: 'Segoe Print', 'Comic Sans MS', cursive;
      color: #5a4327;
      animation: notification-slide 0.5s ease-out;
    }
    @keyframes notification-slide {
      from {
        transform: translateX(-50%) translateY(-100%);
        opacity: 0;
      }
      to {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }
    }
  </style>
  <script src="/socket.io/socket.io.js"></script>
</head>
<body>
  <!-- Ghibli-inspired background elements -->
  <div class="ghibli-stars">
    <span style="left:8vw;top:12vh;width:2.5px;height:2.5px;animation-delay:0s;"></span>
    <span style="left:18vw;top:22vh;width:1.5px;height:1.5px;animation-delay:1.2s;"></span>
    <span style="left:38vw;top:8vh;width:2.2px;height:2.2px;animation-delay:2.1s;"></span>
    <span style="left:62vw;top:18vh;width:1.8px;height:1.8px;animation-delay:0.7s;"></span>
    <span style="left:78vw;top:12vh;width:2.7px;height:2.7px;animation-delay:2.8s;"></span>
    <span style="left:88vw;top:28vh;width:1.2px;height:1.2px;animation-delay:1.7s;"></span>
    <span style="left:55vw;top:6vh;width:1.9px;height:1.9px;animation-delay:0.3s;"></span>
    <span style="left:25vw;top:18vh;width:2.1px;height:2.1px;animation-delay:2.3s;"></span>
    <span style="left:70vw;top:10vh;width:1.6px;height:1.6px;animation-delay:1.1s;"></span>
    <span style="left:48vw;top:24vh;width:2.3px;height:2.3px;animation-delay:0.9s;"></span>
    <span style="left:15vw;top:15vh;width:1.8px;height:1.8px;animation-delay:1.5s;"></span>
    <span style="left:85vw;top:8vh;width:2.0px;height:2.0px;animation-delay:0.5s;"></span>
    <span style="left:35vw;top:25vh;width:1.4px;height:1.4px;animation-delay:2.0s;"></span>
    <span style="left:75vw;top:20vh;width:1.7px;height:1.7px;animation-delay:1.8s;"></span>
    <span style="left:45vw;top:12vh;width:2.1px;height:2.1px;animation-delay:0.8s;"></span>
  </div>

  <!-- Crescent moon -->
  <svg class="ghibli-moon" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M32 4C16.536 4 4 16.536 4 32s12.536 28 28 28c15.464 0 28-12.536 28-28S47.464 4 32 4zm0 4c13.255 0 24 10.745 24 24S45.255 56 32 56c-13.255 0-24-10.745-24-24S18.745 8 32 8z" fill="#fffbe7"/>
    <path d="M32 8c-13.255 0-24 10.745-24 24s10.745 24 24 24c13.255 0 24-10.745 24-24S45.255 8 32 8zm0 4c11.046 0 20 8.954 20 20s-8.954 20-20 20S12 43.046 12 32s8.954-20 20-20z" fill="#1a1a2e"/>
  </svg>

  <!-- Moonlight reflection -->
  <div class="moonlight-reflection"></div>

  <!-- Floating particles -->
  <div class="floating-particles">
    <div class="particle" style="left: 10%; animation-delay: 0s;"></div>
    <div class="particle" style="left: 20%; animation-delay: 3s;"></div>
    <div class="particle" style="left: 30%; animation-delay: 6s;"></div>
    <div class="particle" style="left: 40%; animation-delay: 9s;"></div>
    <div class="particle" style="left: 50%; animation-delay: 12s;"></div>
    <div class="particle" style="left: 60%; animation-delay: 15s;"></div>
    <div class="particle" style="left: 70%; animation-delay: 18s;"></div>
    <div class="particle" style="left: 80%; animation-delay: 21s;"></div>
    <div class="particle" style="left: 90%; animation-delay: 24s;"></div>
  </div>

  <!-- Sunny effects for day mode -->
  <div class="sunny-effects">
    <div class="sun-rays">
      <div class="sun-ray" style="transform: translate(-50%, -50%) rotate(0deg);"></div>
      <div class="sun-ray" style="transform: translate(-50%, -50%) rotate(45deg);"></div>
      <div class="sun-ray" style="transform: translate(-50%, -50%) rotate(90deg);"></div>
      <div class="sun-ray" style="transform: translate(-50%, -50%) rotate(135deg);"></div>
      <div class="sun-ray" style="transform: translate(-50%, -50%) rotate(180deg);"></div>
      <div class="sun-ray" style="transform: translate(-50%, -50%) rotate(225deg);"></div>
      <div class="sun-ray" style="transform: translate(-50%, -50%) rotate(270deg);"></div>
      <div class="sun-ray" style="transform: translate(-50%, -50%) rotate(315deg);"></div>
    </div>
  </div>

  <!-- Floating flowers for day mode -->
  <div class="floating-flowers">
    <div class="flower" style="left: 5%; animation-delay: 0s;"></div>
    <div class="flower" style="left: 15%; animation-delay: 2s;"></div>
    <div class="flower" style="left: 25%; animation-delay: 4s;"></div>
    <div class="flower" style="left: 35%; animation-delay: 6s;"></div>
    <div class="flower" style="left: 45%; animation-delay: 8s;"></div>
    <div class="flower" style="left: 55%; animation-delay: 10s;"></div>
    <div class="flower" style="left: 65%; animation-delay: 12s;"></div>
    <div class="flower" style="left: 75%; animation-delay: 14s;"></div>
    <div class="flower" style="left: 85%; animation-delay: 16s;"></div>
    <div class="flower" style="left: 95%; animation-delay: 18s;"></div>
  </div>
  <!-- Floating happy emojis for day mode -->
  <div class="floating-happy-emojis">
    <div class="happy-emoji" style="left: 10%; animation-delay: 1s;">üòä</div>
    <div class="happy-emoji" style="left: 22%; animation-delay: 3s;">üòÅ</div>
    <div class="happy-emoji" style="left: 34%; animation-delay: 5s;">üòÉ</div>
    <div class="happy-emoji" style="left: 46%; animation-delay: 7s;">üòÑ</div>
    <div class="happy-emoji" style="left: 58%; animation-delay: 9s;">üòÜ</div>
    <div class="happy-emoji" style="left: 70%; animation-delay: 11s;">üòç</div>
    <div class="happy-emoji" style="left: 82%; animation-delay: 13s;">ü•∞</div>
    <div class="happy-emoji" style="left: 94%; animation-delay: 15s;">üòá</div>
  </div>

  <div class="container">
    <!-- Left Panel: Scores and Actions -->
    <div class="left-panel">
      <div class="title-badge" id="gameTitleBadge">Who's Cheating?</div>
      <div class="score-box">
        <div class="score-row">
          <span class="score-label">Party Count</span>
          <span class="score-controls">
            <button class="score-btn host-only" id="partyMinusBtn">-1</button>
            <span class="score-value" id="partyCount">0</span>
            <button class="score-btn host-only" id="partyPlusBtn">+1</button>
          </span>
        </div>
        <div class="score-row">
          <span class="score-label">Scandal Score</span>
          <span class="score-controls">
            <button class="score-btn host-only" id="scandalMinusBtn">-1</button>
            <span class="score-value" id="scandalScore">0</span>
            <button class="score-btn host-only" id="scandalPlusBtn">+1</button>
          </span>
        </div>
        <div class="score-row">
          <span class="score-label">Close-Knot Score</span>
          <span class="score-controls">
            <button class="score-btn host-only" id="closeKnotMinusBtn">-1</button>
            <span class="score-value" id="closeKnotScore">0</span>
            <button class="score-btn host-only" id="closeKnotPlusBtn">+1</button>
          </span>
        </div>
        <div class="score-row">
          <span class="score-label">Vote Count</span>
          <span class="score-controls">
            <button class="score-btn host-only" id="voteMinusBtn">-1</button>
            <span class="score-value" id="voteCount">0</span>
            <button class="score-btn host-only" id="votePlusBtn">+1</button>
          </span>
        </div>
      </div>
      <div class="love-hate-box">
        <div class="love-hate-row">
          <span class="love-hate-label">Love Count</span>
          <span class="love-hate-value" id="loveCount">0</span>
        </div>
        <div class="love-hate-row">
          <span class="love-hate-label">Hate Count</span>
          <span class="love-hate-value hate-value" id="hateCount">0</span>
        </div>
        <button class="action-btn host-only" id="takeActionBtn">Take Action</button>
        <button class="reset-btn host-only" id="resetLoveHateBtn">Reset Count</button>
        <button class="reset-btn host-only" id="resetVoteBtn">Reset Vote</button>
      </div>
    </div>
    <!-- Center Panel: Table and Cards -->
    <div class="center-panel">
      <div class="circle-table-container">
        <div class="circle-table">
          <div class="table-details">
            <div class="table-pattern"></div>
            <div class="table-center-decoration"></div>
          </div>
        </div>
        <div class="role-cards-circle" id="roleCardsCircle" style="z-index: 10;"></div>
      </div>
      <div id="skillButtonContainer" style="margin: 24px 0 0 0; display: flex; gap: 12px;"></div>
      <div style="margin: 24px 0 0 0; display: flex; gap: 12px;">
        <button class="vote-btn" id="voteYesBtn" style="background:#ffe7b2;color:#e26a6a;">‚ù§Ô∏è Love</button>
        <button class="vote-btn" id="voteNoBtn" style="background:#ffe7b2;color:#7a5a2f;">üíî Hate</button>
        <button class="vote-btn" id="voteSubmitBtn" style="background:#b2d7ff;color:#2a4a7a;">Vote</button>
      </div>
    </div>
    <!-- Right Panel: How to Play -->
    <div class="right-panel">
      <div class="score-box" style="min-height: 320px; max-height: 60vh; overflow-y: auto; margin-top: 80px; position: relative;">
        <!-- Removed duplicate toggleStageBtn button from here -->
        <div style="font-size:1.13rem;font-weight:bold;margin-bottom:8px;color:#7bb0e6;letter-spacing:1px;">How to Play</div>
        <div style="font-size:1.05rem;">
          <p><strong>Who's Cheating? ‚Äì Family Feud Edition</strong></p>
          <p>An online, no-elimination social-deduction web game for <strong>6‚Äì9 players</strong>. Over a set number of Family Parties, you'll collect ‚ù§Ô∏è Close-knot or rack up üí• Scandal points. After the final party (or if Scandal hits 10), whoever leads wins‚Äîunless Michael's "Finding Abby" twist upends the result!</p>
          
          <h4>üë™ Players & Parties</h4>
          <p><strong>Pets:</strong> Pets are on the Keeper side and are also Keepers, but have no special power. 2-Pet games (6 or 8): Kiko + Knox. 3-Pet games (7 or 9): Kiko, Knox + Nash.</p>
          <ul>
            <li><strong>5 Players:</strong> 2 Cheaters (Michael, Wind) + 3 Keepers (Abby, Kennedi, Kiko) + 3 Parties</li>
            <li><strong>6 Players:</strong> 2 Cheaters (Michael, Wind) + 4 Keepers (Abby, Kennedi, Kiko, Knox) + 3 Parties</li>
            <li><strong>7 Players:</strong> 2 Cheaters (Michael, Wind) + 5 Keepers (Abby, Kennedi, Kiko, Knox, Nash) + 3 Parties</li>
            <li><strong>8 Players:</strong> 3 Cheaters (Michael, Jack, Wind) + 5 Keepers (Abby, Kennedi, Ker, Kiko, Knox) + 4 Parties</li>
            <li><strong>9 Players:</strong> 3 Cheaters (Michael, Jack, Wind) + 6 Keepers (Abby, Kennedi, Ker, Kiko, Knox, Nash) + 4 Parties</li>
          </ul>

          <h4>üé≤ Components</h4>
          <ul>
            <li>Role cards (one per player)</li>
            <li>Vote cards: ‚úÖ Approve / ‚ùå Reject</li>
            <li>Drama cards: each player's hand of 1 Love + 1 Hate</li>
            <li>Close-knot & Scandal tracks (0‚Üí10)</li>
            <li>Night marker (counts nights)</li>
            <li>Skill buttons are visible only to relevant players</li>
          </ul>

          <h4>üîß Setup</h4>
          <ol>
            <li>Deal each player one secret Role card.</li>
            <li>Abby peeks: View all Cheaters except Jack.</li>
            <li>Cheaters peek (except Jack): recognize one another; Jack stays hidden.</li>
            <li>Initialize tracks at 0; Night marker ‚Üí 0.</li>
            <li>Randomly select the first Election Candidate.</li>
          </ol>

          <h4>üîÑ Round Flow</h4>
          <p><strong>Repeat for N Family Parties (see table above):</strong></p>
          <ol>
            <li><strong>Night (10 sec)</strong><br>
              Rumors fly: Scandal +1.<br>
              Wind may click <em>Molesting a Boy</em> (once) to instead add Scandal +2.<br>
              Advance Night marker.
            </li>
            <li><strong>Host Election & Helpers</strong><br>
              Elect Host: all vote ‚úÖ/‚ùå on the current Election Candidate.<br>
              &gt;50% Approve ‚Üí becomes Host.<br>
              ‚â§50% Approve ‚Üí pass candidate clockwise; return to Night for same party.<br>
              Helpers: The Host picks 2 Helpers.
            </li>
            <li><strong>Family Party (Drama & Scoring)</strong><br>
              <strong>Skill-use window (10 sec):</strong><br>
              Kennedi may click <em>Protecting the Party</em> (once): all 3 cards count as Love ‚Üí Close-knot +3.<br>
              Wind may click <em>Mislead</em> (once): after reveals flip one Love‚ÜíHate ‚Üí Scandal +1.<br>
              If both are used, compare totals at that moment: the higher side's effect applies.<br>
              Play Drama cards: Host + 2 Helpers each play Love or Hate.<br>
              Reveal & tally: Love ‚Üí +1 Close-knot; Hate ‚Üí +1 Scandal.<br>
              Michael may click <em>Finding Abby</em> anytime this Party: name one player as Abby.<br>
              Correct ‚Üí immediate Cheater victory.<br>
              Wrong ‚Üí immediate Keeper victory.<br>
              If Parties remain, loop to Night; otherwise ‚Üí Endgame.
            </li>
          </ol>

          <h4>üîÆ One-Time Role Powers</h4>
          <ul>
            <li><strong>Abby:</strong> Keen Sight - Setup (auto) - Learns all the Cheaters except Jack</li>
            <li><strong>Jack:</strong> I Would Like to Hide My Card - Passive - Jack's identity remains hidden from Abby & other Cheaters</li>
            <li><strong>Wind:</strong> Molesting a Boy - Night - Use instead of +1 ‚Üí Scandal +2</li>
            <li><strong>Wind:</strong> Mislead - After the Party reveals - Flip one Love‚ÜíHate ‚Üí Scandal +1</li>
            <li><strong>Michael:</strong> Creator's Privilege: Finding Abby - Anytime during the Party - Guess Abby; correct ‚Üí Cheaters win; wrong ‚Üí Keepers win</li>
            <li><strong>Kennedi:</strong> Protecting the Party - Before reveals - All 3 cards count as Love ‚Üí Close-knot +3</li>
            <li><strong>Ker:</strong> The Chosen One - After Helpers picked - Swap one chosen Helper with one non-Helper</li>
          </ul>
          <p><em><strong>Note:</strong> Each power is clickable once; button then disables.</em></p>

          <h4>üèÜ Endgame & Victory</h4>
          <ul>
            <li>After all Family Parties:</li>
            <ul>
              <li>Close-knot &gt; Scandal ‚Üí Keepers win</li>
              <li>Scandal ‚â• Close-knot ‚Üí Cheaters win</li>
            </ul>
            <li>Michael's final Finding Abby may overturn a Keeper win if he correctly names Abby.</li>
          </ul>
        </div>
      </div>
      <button class="reset-btn host-only" id="restartBtn" style="margin-top:24px;">Restart the Game</button>
    </div>
  </div>
  <!-- Top right corner switch button, always visible above background/table -->
  <button id="toggleStageBtn" style="position:fixed;top:32px;right:32px;z-index:1000;">üåô Switch to Day</button>
  <div id="gameStateBox" style="display:none;"></div>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    let tempLoveCount = 0;
    let tempHateCount = 0;
    let isSkillPhase = false;
    let currentPlayer = null;
    let gameState = null;

    // Get DOM elements
    const loveBtn = document.getElementById('voteYesBtn');
    const hateBtn = document.getElementById('voteNoBtn');
    const loveCount = document.getElementById('loveCount');
    const hateCount = document.getElementById('hateCount');
    const windSkillBtn = document.getElementById('windSkillBtn');
    const kennediSkillBtn = document.getElementById('kennediSkillBtn');
    const roleCardsCircle = document.getElementById('roleCardsCircle');
    const uiMessageBox = document.createElement('div');
    uiMessageBox.style.cssText = `
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 30px;
      border-radius: 10px;
      font-size: 1.2em;
      z-index: 1000;
      display: none;
    `;
    document.body.appendChild(uiMessageBox);

    // Function to position cards in a circle
    function positionCardsInCircle(players) {
      roleCardsCircle.innerHTML = '';
      const n = players.length;
      const radius = 210; // Place cards around the edge of the table
      const centerX = 260;
      const centerY = 260;
      const cardWidth = 68;
      const cardHeight = 96;

      // Find current player's role
      const currentPlayer = players.find(p => p.id === socket.id);
      const myRole = currentPlayer ? currentPlayer.role : null;
      const myRoleLower = myRole ? myRole.toLowerCase() : '';

      players.forEach((player, index) => {
        const angle = (index * 2 * Math.PI) / n - Math.PI / 2; // Start from top
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        const cardContainer = document.createElement('div');
        cardContainer.style.cssText = `position: absolute; left: ${x}px; top: ${y}px; transform: translate(-50%, -50%); width: ${cardWidth}px; height: ${cardHeight}px; transition: all 0.3s ease;`;
        const roleCard = document.createElement('img');
        roleCard.className = 'role-card';
        roleCard.style.width = cardWidth + 'px';
        roleCard.style.height = cardHeight + 'px';

        // Role visibility logic
        let shouldShowCard = false;
        const playerRoleLower = player.role ? player.role.toLowerCase() : '';

        if (player.id === socket.id) {
          // Everyone can see their own card
          shouldShowCard = true;
          roleCard.classList.add('me');
        } else if (myRoleLower === 'abby') {
          // Abby can see Michael and Wind's cards only
          shouldShowCard = (playerRoleLower === 'michael' || playerRoleLower === 'wind');
        } else if (myRoleLower === 'michael' || myRoleLower === 'wind') {
          // Michael and Wind can see each other's cards
          shouldShowCard = (playerRoleLower === 'michael' || playerRoleLower === 'wind');
        } else {
          // All other roles (Jack, Kennedi, Ker, Kiko, Knox, Nash) can only see their own card
          shouldShowCard = false;
        }

        // Set card image based on visibility
        if (shouldShowCard) {
          roleCard.src = `/imgs/${player.role ? player.role.toLowerCase() : 'backSide'}.png`;
        } else {
          roleCard.src = '/imgs/backSide.png';
        }

        const nameLabel = document.createElement('div');
        nameLabel.className = 'player-name-label';
        nameLabel.textContent = player.name + (player.isHost ? ' (Host)' : '');
        cardContainer.appendChild(roleCard);
        cardContainer.appendChild(nameLabel);
        roleCardsCircle.appendChild(cardContainer);
      });
    }

    // Show UI message
    function showUIMessage(text, duration) {
      uiMessageBox.textContent = text;
      uiMessageBox.style.display = 'block';
      if (duration) {
        setTimeout(() => {
          uiMessageBox.style.display = 'none';
          if (text.includes('Wind and Kennedi')) {
            isSkillPhase = false;
            if (windSkillBtn) windSkillBtn.disabled = true;
            if (kennediSkillBtn) kennediSkillBtn.disabled = true;
          }
        }, duration);
      }
    }

    // --- UI Message-Driven Button States ---
    let loveHateWindow = false;
    let voteWindow = false;
    let windKennediSkillWindow = false;
    let loveHateClickedThisRound = false;

    // Function to reset all button states to initial disabled state
    function resetAllButtonStates() {
      console.log('[resetAllButtonStates] Resetting all button states to initial disabled state');
      
      // Clear any ongoing timers
      if (window.loveHateTimer) {
        clearTimeout(window.loveHateTimer);
        window.loveHateTimer = null;
      }
      if (window.voteTimer) {
        clearTimeout(window.voteTimer);
        window.voteTimer = null;
      }
      if (window.skillWindowTimer) {
        clearTimeout(window.skillWindowTimer);
        window.skillWindowTimer = null;
      }
      
      // Reset love/hate buttons
      loveHateWindow = false;
      loveHateClickedThisRound = false;
      loveBtn.disabled = true;
      hateBtn.disabled = true;
      
      // Reset vote buttons
      voteWindow = false;
      const voteYesBtn = document.getElementById('voteYesBtn');
      const voteNoBtn = document.getElementById('voteNoBtn');
      const voteSubmitBtn = document.getElementById('voteSubmitBtn');
      if (voteYesBtn) voteYesBtn.disabled = true;
      if (voteNoBtn) voteNoBtn.disabled = true;
      if (voteSubmitBtn) voteSubmitBtn.disabled = true;
      
      // Reset skill window state
      windKennediSkillWindow = false;
      
      // Re-render skill buttons (they will be disabled based on new game state)
      renderSkillButtons();
      
      console.log('[resetAllButtonStates] All button states reset');
    }

    function setLoveHateWindow(enabled) {
      loveHateWindow = enabled;
      loveBtn.disabled = !enabled || loveHateClickedThisRound;
      hateBtn.disabled = !enabled || loveHateClickedThisRound;
    }
    function setVoteWindow(enabled) {
      voteWindow = enabled;
      document.getElementById('voteYesBtn').disabled = !enabled;
      document.getElementById('voteNoBtn').disabled = !enabled;
      document.getElementById('voteSubmitBtn').disabled = !enabled;
    }
    function setWindKennediSkillWindow(enabled) {
      windKennediSkillWindow = enabled;
      renderSkillButtons();
    }

    // --- Listen for UI Messages to Control Button States ---
    socket.on('uiMessage', (message) => {
      console.log('[uiMessage received]', message);
      if (message) {
        showUIMessage(message.text, 10000);
        if (message.text.includes('Host and helpers can do their action right now')) {
          loveHateClickedThisRound = false;
          setLoveHateWindow(true);
          window.loveHateTimer = setTimeout(() => setLoveHateWindow(false), 10000);
        }
        if (message.text.includes('Host and helpers please take your action, and Wind and Kennedi can use their skills now!')) {
          setLoveHateWindow(true);
          setWindKennediSkillWindow(true);
          renderSkillButtons();
          window.skillWindowTimer = setTimeout(() => {
            setLoveHateWindow(false);
            setWindKennediSkillWindow(false);
            renderSkillButtons();
          }, 10000);
        }
        if (message.text.includes('Every player can vote now!')) {
          setVoteWindow(true);
          window.voteTimer = setTimeout(() => setVoteWindow(false), 10000);
        }
        renderSkillButtons();
      }
    });

    // --- Love/Hate/Vote Button One-Time Use Logic ---
    loveBtn.addEventListener('click', () => {
      if (!loveBtn.disabled && loveHateWindow && !loveHateClickedThisRound) {
        loveHateClickedThisRound = true;
        loveBtn.disabled = true;
        hateBtn.disabled = true;
        socket.emit('loveHateAction', { type: 'love' });
      }
    });
    hateBtn.addEventListener('click', () => {
      if (!hateBtn.disabled && loveHateWindow && !loveHateClickedThisRound) {
        loveHateClickedThisRound = true;
        loveBtn.disabled = true;
        hateBtn.disabled = true;
        socket.emit('loveHateAction', { type: 'hate' });
      }
    });
    document.getElementById('voteSubmitBtn').addEventListener('click', () => {
      if (!voteWindow) return;
      document.getElementById('voteYesBtn').disabled = true;
      document.getElementById('voteNoBtn').disabled = true;
      document.getElementById('voteSubmitBtn').disabled = true;
      // Emit vote action to server
      socket.emit('gameAction', { roomId, action: 'vote', playerName: myName });
    });

    // Update love/hate counts only when server sends final counts
    socket.on('updateLoveHateCount', ({ love, hate }) => {
      loveCount.textContent = love;
      hateCount.textContent = hate;
    });
    socket.on('gameStateUpdate', (newGameState) => {
      gameState = newGameState;
      console.log('[gameStateUpdate]', newGameState);
      
      // Check if this is a restart (all scores are 0 and isDay is false)
      const isRestart = newGameState.partyCount === 0 && 
                       newGameState.scandalScore === 0 && 
                       newGameState.closeKnotScore === 0 && 
                       newGameState.voteCount === 0 && 
                       newGameState.loveCount === 0 && 
                       newGameState.hateCount === 0 && 
                       newGameState.isDay === false;
      
      // Log role changes if this is a restart
      if (gameState && newGameState && gameState.players && newGameState.players) {
        const oldRoles = gameState.players.map(p => ({ name: p.name, role: p.role }));
        const newRoles = newGameState.players.map(p => ({ name: p.name, role: p.role }));
        console.log('[gameStateUpdate] Role changes:', { oldRoles, newRoles });
        
        // If roles have changed, this is definitely a restart
        const rolesChanged = JSON.stringify(oldRoles) !== JSON.stringify(newRoles);
        if (rolesChanged || isRestart) {
          console.log('[gameStateUpdate] Restart detected, resetting button states');
          resetAllButtonStates();
        }
      }
      
      // Update score displays
      if (gameState.partyCount !== undefined) {
        document.getElementById('partyCount').textContent = gameState.partyCount;
      }
      if (gameState.scandalScore !== undefined) {
        document.getElementById('scandalScore').textContent = gameState.scandalScore;
      }
      if (gameState.closeKnotScore !== undefined) {
        document.getElementById('closeKnotScore').textContent = gameState.closeKnotScore;
      }
      if (gameState.voteCount !== undefined) {
        document.getElementById('voteCount').textContent = gameState.voteCount;
      }
      if (gameState.loveCount !== undefined) {
        loveCount.textContent = gameState.loveCount;
      }
      if (gameState.hateCount !== undefined) {
        hateCount.textContent = gameState.hateCount;
      }
      
      // Update day/night mode
      if (gameState.isDay !== undefined) {
        if (gameState.isDay) {
          document.body.classList.add('day-mode');
        } else {
          document.body.classList.remove('day-mode');
        }
      }
      
      if (gameState.players) {
        positionCardsInCircle(gameState.players);
        updateHostOnlyButtons();
        renderSkillButtons();
      }
      if (roleCheckTimer) clearTimeout(roleCheckTimer);
      roleCheckTimer = setTimeout(checkRoleAssigned, 5000);
    });

    // Handle skill buttons
    if (windSkillBtn) {
      windSkillBtn.addEventListener('click', () => {
        if (!windSkillBtn.disabled && isSkillPhase) {
          socket.emit('gameAction', { roomId, action: 'useSkill', data: { skill: 'mislead' }, playerName: myName });
          windSkillBtn.disabled = true;
        }
      });
    }

    if (kennediSkillBtn) {
      kennediSkillBtn.addEventListener('click', () => {
        if (!kennediSkillBtn.disabled && isSkillPhase) {
          socket.emit('useSkill', { skill: 'protectingparty' });
          kennediSkillBtn.disabled = true;
        }
      });
    }

    // Socket event listeners
    socket.on('enableLoveHate', () => {
      loveBtn.disabled = false;
      hateBtn.disabled = false;
    });

    socket.on('disableLoveHate', () => {
      loveBtn.disabled = true;
      hateBtn.disabled = true;
    });

    // Debug: Log all socket events
    socket.onAny((event, ...args) => {
      console.log('[Socket Event]', event, ...args);
    });

    // Handle initial game state
    socket.on('initialGameState', (state) => {
      console.log('[initialGameState]', state);
      gameState = state;
      
      // Update score displays
      if (gameState.partyCount !== undefined) {
        document.getElementById('partyCount').textContent = gameState.partyCount;
      }
      if (gameState.scandalScore !== undefined) {
        document.getElementById('scandalScore').textContent = gameState.scandalScore;
      }
      if (gameState.closeKnotScore !== undefined) {
        document.getElementById('closeKnotScore').textContent = gameState.closeKnotScore;
      }
      if (gameState.voteCount !== undefined) {
        document.getElementById('voteCount').textContent = gameState.voteCount;
      }
      if (gameState.loveCount !== undefined) {
        loveCount.textContent = gameState.loveCount;
      }
      if (gameState.hateCount !== undefined) {
        hateCount.textContent = gameState.hateCount;
      }
      
      // Update day/night mode
      if (gameState.isDay !== undefined) {
        if (gameState.isDay) {
          document.body.classList.add('day-mode');
        } else {
          document.body.classList.remove('day-mode');
        }
      }
      
      if (gameState.players) {
        positionCardsInCircle(gameState.players);
        updateHostOnlyButtons();
        renderSkillButtons();
      }
      if (roleCheckTimer) clearTimeout(roleCheckTimer);
      roleCheckTimer = setTimeout(checkRoleAssigned, 5000);
    });

    // --- Room Join Logic ---
    function getQueryParams() {
      const params = {};
      window.location.search.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(str,key,value) {
        params[key] = decodeURIComponent(value);
      });
      return params;
    }
    const params = getQueryParams();
    const roomId = params.roomId || '00000';
    let myName = params.name || '';
    const password = params.password || '';
    const roomName = params.roomname || '';
    const maxPlayers = params.maxPlayers || 5;
    const isCreateRoom = params.createRoom === '1';
    if (!myName) {
      myName = prompt('Enter your name:');
    }
    if (isCreateRoom) {
      // Host: create the room first, then join
      socket.emit('createRoom', { roomId, password, maxPlayers, hostName: myName, roomName }, (res) => {
        if (res.success) {
          // Room created successfully, now join it
          socket.emit('joinRoom', { roomId, playerName: myName }, (res2) => {
            if (!res2.success) {
              alert(res2.message || 'Failed to join room.');
              window.location.href = 'joining.html';
            }
          });
        } else if (res.message && res.message.includes('already exists')) {
          // Room already exists, just join it
          console.log('Room already exists, joining existing room...');
          socket.emit('joinRoom', { roomId, playerName: myName }, (res2) => {
            if (!res2.success) {
              alert(res2.message || 'Failed to join existing room.');
              window.location.href = 'joining.html';
            }
          });
        } else {
          alert(res.message || 'Failed to create test room.');
          window.location.href = 'joining.html';
        }
      });
    } else {
      // Regular player: just join
      socket.emit('joinRoom', { roomId, playerName: myName }, (res) => {
        if (!res.success) {
          alert(res.message || 'Failed to join room.');
          window.location.href = 'joining.html';
        }
      });
    }
    // Always listen for both initialGameState and gameStateUpdate
    socket.on('initialGameState', (state) => {
      gameState = state;
      // Update UI with latest game state
      if (gameState.partyCount !== undefined) {
        document.getElementById('partyCount').textContent = gameState.partyCount;
      }
      if (gameState.scandalScore !== undefined) {
        document.getElementById('scandalScore').textContent = gameState.scandalScore;
      }
      if (gameState.closeKnotScore !== undefined) {
        document.getElementById('closeKnotScore').textContent = gameState.closeKnotScore;
      }
      if (gameState.voteCount !== undefined) {
        document.getElementById('voteCount').textContent = gameState.voteCount;
      }
      if (gameState.loveCount !== undefined) {
        loveCount.textContent = gameState.loveCount;
      }
      if (gameState.hateCount !== undefined) {
        hateCount.textContent = gameState.hateCount;
      }
      // Update day/night mode
      if (gameState.isDay !== undefined) {
        if (gameState.isDay) {
          document.body.classList.add('day-mode');
        } else {
          document.body.classList.remove('day-mode');
        }
      }
      if (gameState.players) {
        positionCardsInCircle(gameState.players);
        updateHostOnlyButtons();
        renderSkillButtons();
      }
      if (roleCheckTimer) clearTimeout(roleCheckTimer);
      roleCheckTimer = setTimeout(checkRoleAssigned, 5000);
    });

    // --- Host-Only Controls and Default State ---
    function updateHostOnlyButtons() {
      if (!gameState || !gameState.players) return;
      const me = gameState.players.find(p => p.id === socket.id);
      const isHost = me && me.isHost;
      document.querySelectorAll('.host-only').forEach(btn => {
        btn.disabled = !isHost;
      });
      // Only host can switch day/night
      const toggleStageBtn = document.getElementById('toggleStageBtn');
      if (toggleStageBtn) toggleStageBtn.disabled = !isHost;
    }

    // --- Skill Button Logic (robust) ---
    function renderSkillButtons() {
      const skillButtonContainer = document.getElementById('skillButtonContainer');
      skillButtonContainer.innerHTML = '';
      if (!gameState || !gameState.players) return;
      const me = gameState.players.find(p => p.id === socket.id);
      if (!me || !me.role) return;
      const role = me.role;
      const usedSkills = (gameState.usedActions && gameState.usedActions.skills && gameState.usedActions.skills[me.name]) || {};
      // Hide skill buttons for pets, Jack, Abby
      const noSkillRoles = ['Kiko', 'Knox', 'Nash', 'Jack', 'Abby'];
      if (noSkillRoles.includes(role)) {
        skillButtonContainer.style.display = 'none';
        skillButtonContainer.innerHTML = '';
        return;
      }
      skillButtonContainer.style.display = 'flex';
      skillButtonContainer.style.flexDirection = 'row';
      // Wind: two skill buttons
      if (role === 'Wind') {
        // Molest: only usable at night, one-time
        const molestBtn = document.createElement('button');
        molestBtn.className = 'skill-btn';
        molestBtn.textContent = 'Molest';
        const isNight = !gameState.isDay;
        molestBtn.disabled = !!usedSkills['molest'] || !isNight;
        molestBtn.onclick = function() {
          if (molestBtn.disabled) return;
          molestBtn.disabled = true;
          socket.emit('gameAction', { roomId, action: 'useSkill', data: { skill: 'molest' }, playerName: myName });
        };
        skillButtonContainer.appendChild(molestBtn);
        // Mislead: only enabled during skill window, one-time
        const misleadBtn = document.createElement('button');
        misleadBtn.className = 'skill-btn';
        misleadBtn.textContent = 'Mislead';
        misleadBtn.disabled = !!usedSkills['mislead'] || !windKennediSkillWindow;
        misleadBtn.onclick = function() {
          if (misleadBtn.disabled) return;
          misleadBtn.disabled = true;
          // Use direct useSkill event for skill window skills
          socket.emit('useSkill', { skill: 'mislead' });
        };
        skillButtonContainer.appendChild(misleadBtn);
        return;
      }
      // Michael: Find Abby (one-time, always enabled if not used)
      if (role === 'Michael') {
        const abbyBtn = document.createElement('button');
        abbyBtn.className = 'skill-btn';
        abbyBtn.textContent = 'Find Abby';
        abbyBtn.disabled = !!usedSkills['findabby'];
        abbyBtn.onclick = function() {
          if (abbyBtn.disabled) return;
          abbyBtn.disabled = true;
          socket.emit('gameAction', { roomId, action: 'useSkill', data: { skill: 'findabby' }, playerName: myName });
        };
        skillButtonContainer.appendChild(abbyBtn);
        return;
      }
      // Kennedi: Protecting Party (one-time, only enabled during skill window)
      if (role === 'Kennedi') {
        const protectBtn = document.createElement('button');
        protectBtn.className = 'skill-btn';
        protectBtn.textContent = 'Protecting Party';
        protectBtn.disabled = !!usedSkills['protectingparty'] || !windKennediSkillWindow;
        protectBtn.onclick = function() {
          if (protectBtn.disabled) return;
          protectBtn.disabled = true;
          // Use direct useSkill event for skill window skills
          socket.emit('useSkill', { skill: 'protectingparty' });
        };
        skillButtonContainer.appendChild(protectBtn);
        return;
      }
      // Ker: The Chosen One (one-time, always enabled if not used)
      if (role === 'Ker') {
        const kerBtn = document.createElement('button');
        kerBtn.className = 'skill-btn';
        kerBtn.textContent = 'The Chosen One';
        kerBtn.disabled = !!usedSkills['thechosenone'];
        kerBtn.onclick = function() {
          if (kerBtn.disabled) return;
          kerBtn.disabled = true;
          handleKerSkill();
        };
        skillButtonContainer.appendChild(kerBtn);
        return;
      }
    }

    // --- Ker's Popup ---
    function showKerPopup() {
      const popup = document.createElement('div');
      popup.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#fffbe7;border:2px solid #e2c391;padding:24px;z-index:2000;border-radius:16px;box-shadow:0 2px 18px #23202a22;';
      popup.innerHTML = `<b>The Chosen One</b><br><br>Pick the helper to swap:<br><input id="kerHelper" style="width:180px;"><br><br>Pick the non-helper candidate:<br><input id="kerNonHelper" style="width:180px;"><br><br><button id="kerSubmit">Submit</button> <button id="kerCancel">Cancel</button>`;
      document.body.appendChild(popup);
      document.getElementById('kerSubmit').onclick = function() {
        const helper = document.getElementById('kerHelper').value;
        const nonHelper = document.getElementById('kerNonHelper').value;
        socket.emit('gameAction', { roomId, action: 'theChosenOne', data: { oldHelper: helper, newHelper: nonHelper }, playerName: myName });
        document.body.removeChild(popup);
      };
      document.getElementById('kerCancel').onclick = function() {
        document.body.removeChild(popup);
      };
    }

    // --- Default State on Load ---
    document.addEventListener('DOMContentLoaded', () => {
      document.body.classList.remove('day-mode'); // Night mode by default
      
      // Initialize background elements for night mode
      const stars = document.querySelector('.ghibli-stars');
      const moon = document.querySelector('.ghibli-moon');
      const moonlight = document.querySelector('.moonlight-reflection');
      const particles = document.querySelector('.floating-particles');
      const sunnyEffects = document.querySelector('.sunny-effects');
      const floatingFlowers = document.querySelector('.floating-flowers');
      
      if (stars) stars.style.opacity = '1';
      if (moon) moon.style.opacity = '0.18';
      if (moonlight) moonlight.style.opacity = '1';
      if (particles) particles.style.opacity = '1';
      if (sunnyEffects) sunnyEffects.style.opacity = '0';
      if (floatingFlowers) floatingFlowers.style.opacity = '0';
      
      // Set all counts to 0
      document.querySelectorAll('.score-value').forEach(el => el.textContent = '0');
      loveCount.textContent = '0';
      hateCount.textContent = '0';
      // Disable all action buttons by default
      document.querySelectorAll('.action-btn, .reset-btn, .vote-btn').forEach(btn => btn.disabled = true);
      // Skill buttons will be rendered by renderSkillButtons

      // --- Host-Only Button Event Listeners ---
      const hostBtnMap = [
        { id: 'partyPlusBtn', action: { action: 'updateCount', data: { countType: 'party', delta: 1 } } },
        { id: 'partyMinusBtn', action: { action: 'updateCount', data: { countType: 'party', delta: -1 } } },
        { id: 'scandalPlusBtn', action: { action: 'updateCount', data: { countType: 'scandal', delta: 1 } } },
        { id: 'scandalMinusBtn', action: { action: 'updateCount', data: { countType: 'scandal', delta: -1 } } },
        { id: 'closeKnotPlusBtn', action: { action: 'updateCount', data: { countType: 'closeKnot', delta: 1 } } },
        { id: 'closeKnotMinusBtn', action: { action: 'updateCount', data: { countType: 'closeKnot', delta: -1 } } },
        { id: 'votePlusBtn', action: { action: 'updateCount', data: { countType: 'vote', delta: 1 } } },
        { id: 'voteMinusBtn', action: { action: 'updateCount', data: { countType: 'vote', delta: -1 } } },
        { id: 'takeActionBtn', action: { action: 'takeLoveHateAction', data: {} } },
        { id: 'resetLoveHateBtn', action: { action: 'resetLoveHateCount', data: {} } },
        { id: 'resetVoteBtn', action: { action: 'resetVote', data: {} } },
        { id: 'restartBtn', action: { action: 'restartGame', data: {} } },
        { id: 'toggleStageBtn', action: { action: 'switchDayNight', data: {} }, isToggle: true }
      ];
      hostBtnMap.forEach(({ id, action, isToggle }) => {
        const btn = document.getElementById(id);
        if (btn) {
          btn.addEventListener('click', () => {
            if (id === 'toggleStageBtn') {
              // Toggle day/night
              const isDay = !document.body.classList.contains('day-mode');
              socket.emit('gameAction', { roomId, action: 'switchDayNight', data: { isDay }, playerName: myName });
            } else {
              socket.emit('gameAction', { roomId, ...action, playerName: myName });
            }
          });
        }
      });
    });

    function renderRoleCards() {
      const container = document.getElementById('roleCardsCircle');
      container.innerHTML = '';
      const n = playerNames.length;
      const radius = 240;
      
      // Role info for tooltip
      const roleInfo = {
        michael: {name:'Michael', team:'Cheater', power:'Can see Wind\'s card. Can guess Abby for instant win'},
        wind: {name:'Wind', team:'Cheater', power:'Can see Michael\'s card. Molest: +2 Scandal; Mislead: flip Love‚ÜíHate'},
        jack: {name:'Jack', team:'Cheater', power:'Hidden from everyone except self'},
        abby: {name:'Abby', team:'Keeper', power:'Can see Michael and Wind'},
        kennedi: {name:'Kennedi', team:'Keeper', power:'Can see own card. All Helpers count as Love'},
        ker: {name:'Ker', team:'Keeper', power:'Can see own card. Can swap one Helper'},
        kiko: {name:'Kiko', team:'Keeper (Pet)', power:'No special power'},
        knox: {name:'Knox', team:'Keeper (Pet)', power:'No special power'},
        nash: {name:'Nash', team:'Keeper (Pet)', power:'No special power'}
      };

      // Lowercase role for comparison
      const myRoleLower = myRole ? myRole.toLowerCase() : '';
      
      // Calculate angles for players with equal spacing
      const angles = Array.from({length: n}, (_, i) => {
        return (Math.PI / 2) + (i * (2 * Math.PI / n));
      });

      playerNames.forEach((name, i) => {
        const angle = angles[i];
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);
        
        // Create role card
        const card = document.createElement('img');
        card.className = 'role-card player-card' + (i === myIndex ? ' me' : '');
        card.style.left = `calc(50% + ${x}px - 45px)`;
        card.style.top = `calc(50% + ${y}px - 67.5px)`;
        
        // Show card face-up based on role-specific rules
        const role = shuffledRoles[i];
        const roleLower = role ? role.toLowerCase() : '';
        let shouldShowCard = false;

        if (i === myIndex) {
          // Everyone can see their own card
          shouldShowCard = true;
        } else if (myRoleLower === 'abby') {
          // Abby can see Michael and Wind's cards only
          shouldShowCard = (roleLower === 'michael' || roleLower === 'wind');
        } else if (myRoleLower === 'michael' || myRoleLower === 'wind') {
          // Michael and Wind can see each other's cards
          shouldShowCard = (roleLower === 'michael' || roleLower === 'wind');
        } else {
          // All other roles (Jack, Kennedi, Ker, Kiko, Knox, Nash) can only see their own card
          shouldShowCard = false;
        }

        card.setAttribute('data-player', name);
        card.src = shouldShowCard ? roleImages[role] : backsideImg;
        card.alt = shouldShowCard ? role : 'Hidden';
        container.appendChild(card);

        // Add role intro tooltip for myself only
        if (i === myIndex) {
          const tooltip = document.createElement('div');
          tooltip.className = 'role-intro-tooltip';
          const info = roleInfo[myRoleLower];
          tooltip.innerHTML = `<div class='role-title'>${info.name} (${info.team})</div><div><b>Power:</b> ${info.power}</div>`;
          card.addEventListener('mouseenter',()=>{tooltip.classList.add('active');});
          card.addEventListener('mouseleave',()=>{tooltip.classList.remove('active');});
          container.appendChild(tooltip);
        }

        // Add player name label with adjusted positioning
        const nameLabel = document.createElement('div');
        nameLabel.className = 'player-name-label';
        const nameOffsetY = y > 0 ? 100 : -100;
        nameLabel.style.left = `calc(50% + ${x}px)`;
        nameLabel.style.top = `calc(50% + ${y + nameOffsetY}px)`;
        nameLabel.textContent = name;
        container.appendChild(nameLabel);
      });
    }

    // Handle Ker's skill
    function handleKerSkill() {
      const dialog = document.createElement('div');
      dialog.className = 'ker-skill-dialog';
      dialog.innerHTML = `
        <div class="dialog-content">
          <h3>The Chosen One</h3>
          <div class="input-section">
            <label>Pick the helper to swap:</label>
            <input type="text" id="helperToSwap" placeholder="Enter helper name">
          </div>
          <div class="input-section">
            <label>Pick the non-helper candidate:</label>
            <input type="text" id="newHelper" placeholder="Enter non-helper name">
          </div>
          <button onclick="submitKerSwap()">Confirm Swap</button>
          <button onclick="closeKerDialog()">Cancel</button>
        </div>
      `;
      document.body.appendChild(dialog);
    }

    function submitKerSwap() {
      const helperToSwap = document.getElementById('helperToSwap').value;
      const newHelper = document.getElementById('newHelper').value;
      if (helperToSwap && newHelper) {
        socket.emit('gameAction', { roomId, action: 'theChosenOne', data: { oldHelper: helperToSwap, newHelper: newHelper }, playerName: myName });
        closeKerDialog();
      }
    }

    function closeKerDialog() {
      const dialog = document.querySelector('.ker-skill-dialog');
      if (dialog) dialog.remove();
    }

    // Handle Wind and Kennedi's skill phase
    function handleLoveHate(action) {
      if (isSkillPhase) return;
      
      if (action === 'love') {
        tempLoveCount++;
      } else {
        tempHateCount++;
      }
      
      // Disable love/hate buttons after use
      document.getElementById('loveBtn').disabled = true;
      document.getElementById('hateBtn').disabled = true;
      
      // Enable Wind and Kennedi's skills
      isSkillPhase = true;
      if (windSkillBtn) windSkillBtn.disabled = false;
      if (kennediSkillBtn) kennediSkillBtn.disabled = false;
      
      showUIMessage("Wind and Kennedi are allowed to use their skills right now!", 10000);
      
      // After 10 seconds, disable skills and apply temp counts
      setTimeout(() => {
        isSkillPhase = false;
        if (windSkillBtn) windSkillBtn.disabled = true;
        if (kennediSkillBtn) kennediSkillBtn.disabled = true;
        
        // Apply the temporary counts
        if (tempLoveCount > 0) {
          socket.emit('updateLoveCount', tempLoveCount);
        }
        if (tempHateCount > 0) {
          socket.emit('updateHateCount', tempHateCount);
        }
        
        // Reset temp counts
        tempLoveCount = 0;
        tempHateCount = 0;
        
        // Re-enable love/hate buttons
        document.getElementById('loveBtn').disabled = false;
        document.getElementById('hateBtn').disabled = false;
      }, 10000);
    }

    // Handle Wind's molest skill
    function handleWindMolest() {
      if (!isSkillPhase) return;
      socket.emit('gameAction', { roomId, action: 'useSkill', data: { skill: 'molest' }, playerName: myName });
      if (windSkillBtn) windSkillBtn.disabled = true;
    }

    // Handle Wind's mislead skill
    function handleWindMislead() {
      if (!isSkillPhase) return;
      socket.emit('useSkill', { skill: 'mislead' });
      if (windSkillBtn) windSkillBtn.disabled = true;
    }

    // Handle Kennedi's protect skill
    function handleKennediProtect() {
      if (!isSkillPhase) return;
      socket.emit('useSkill', { skill: 'protectingparty' });
      if (kennediSkillBtn) kennediSkillBtn.disabled = true;
    }

    // Handle Michael's find Abby skill
    function handleMichaelFindAbby() {
      socket.emit('gameAction', { roomId, action: 'useSkill', data: { skill: 'findabby' }, playerName: myName });
      if (michaelSkillBtn) michaelSkillBtn.disabled = true;
    }

    // Add CSS for Ker's skill dialog
    const style = document.createElement('style');
    style.textContent = `
      .ker-skill-dialog {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }
      .dialog-content {
        background: #fffbe7;
        padding: 20px;
        border-radius: 12px;
        border: 2px solid #e2c391;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }
      .input-section {
        margin: 15px 0;
      }
      .input-section label {
        display: block;
        margin-bottom: 5px;
        color: #5a4327;
      }
      .input-section input {
        width: 100%;
        padding: 8px;
        border: 1px solid #e2c391;
        border-radius: 4px;
      }
      .dialog-content button {
        margin: 5px;
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        background: #e2c391;
        color: #5a4327;
        cursor: pointer;
      }
      .dialog-content button:hover {
        background: #bfa16a;
      }
    `;
    document.head.appendChild(style);

    // Host controls
    function initializeHostControls() {
      if (!isHost) return;

      const hostControls = document.createElement('div');
      hostControls.className = 'host-controls';
      hostControls.innerHTML = `
        <button class="host-button" onclick="toggleDayNight()">Toggle Day/Night</button>
        <button class="host-button" onclick="restartGame()">Restart Game</button>
        <button class="host-button" onclick="toggleHostHelper()" id="hostHelperBtn">Select Party Hosts</button>
        <button class="host-button" onclick="resetPartyHosts()" id="resetHostsBtn">Reset Party Hosts</button>
      `;
      document.body.appendChild(hostControls);

      const countControls = document.createElement('div');
      countControls.className = 'count-controls';
      countControls.innerHTML = `
        <button class="count-button" onclick="updateLoveCount(1)">Love +1</button>
        <button class="count-button" onclick="updateLoveCount(-1)">Love -1</button>
        <button class="count-button" onclick="updateHateCount(1)">Hate +1</button>
        <button class="count-button" onclick="updateHateCount(-1)">Hate -1</button>
        <button class="count-button" onclick="updateScandal(1)">Scandal +1</button>
        <button class="count-button" onclick="updateScandal(-1)">Scandal -1</button>
      `;
      document.body.appendChild(countControls);
    }

    function toggleDayNight() {
      if (!isHost) return;
      const isNight = document.body.classList.toggle('night-mode');
      document.querySelector('.table').classList.toggle('night-mode', isNight);
      document.querySelectorAll('.role-card').forEach(card => card.classList.toggle('night-mode', isNight));
      document.querySelectorAll('.player-name-label').forEach(label => label.classList.toggle('night-mode', isNight));
      document.querySelectorAll('.host-button, .count-button').forEach(btn => btn.classList.toggle('night-mode', isNight));
      
      // Handle background elements
      const stars = document.querySelector('.ghibli-stars');
      const moon = document.querySelector('.ghibli-moon');
      const moonlight = document.querySelector('.moonlight-reflection');
      const particles = document.querySelector('.floating-particles');
      const sunnyEffects = document.querySelector('.sunny-effects');
      const floatingFlowers = document.querySelector('.floating-flowers');
      
      if (isNight) {
        // Show night elements
        if (stars) stars.style.opacity = '1';
        if (moon) moon.style.opacity = '0.18';
        if (moonlight) moonlight.style.opacity = '1';
        if (particles) particles.style.opacity = '1';
        if (sunnyEffects) sunnyEffects.style.opacity = '0';
        if (floatingFlowers) floatingFlowers.style.opacity = '0';
      } else {
        // Hide night elements for day mode
        if (stars) stars.style.opacity = '0.3';
        if (moon) moon.style.opacity = '0.05';
        if (moonlight) moonlight.style.opacity = '0.2';
        if (particles) particles.style.opacity = '0.5';
        if (sunnyEffects) sunnyEffects.style.opacity = '1';
        if (floatingFlowers) floatingFlowers.style.opacity = '1';
      }
      
      socket.emit('toggleDayNight', isNight);
    }

    function restartGame() {
      if (!isHost) return;
      if (confirm('Are you sure you want to restart the game?')) {
        socket.emit('gameAction', { roomId, action: 'restartGame', data: {}, playerName: myName });
      }
    }

    function updateLoveCount(delta) {
      if (!isHost) return;
      socket.emit('updateLoveCount', delta);
    }

    function updateHateCount(delta) {
      if (!isHost) return;
      socket.emit('updateHateCount', delta);
    }

    function updateScandal(delta) {
      if (!isHost) return;
      socket.emit('updateScandal', delta);
    }

    // Socket event handlers
    socket.on('toggleDayNight', (isNight) => {
      document.body.classList.toggle('night-mode', isNight);
      document.querySelector('.table').classList.toggle('night-mode', isNight);
      document.querySelectorAll('.role-card').forEach(card => card.classList.toggle('night-mode', isNight));
      document.querySelectorAll('.player-name-label').forEach(label => label.classList.toggle('night-mode', isNight));
      document.querySelectorAll('.host-button, .count-button').forEach(btn => btn.classList.toggle('night-mode', isNight));
      
      // Handle background elements
      const stars = document.querySelector('.ghibli-stars');
      const moon = document.querySelector('.ghibli-moon');
      const moonlight = document.querySelector('.moonlight-reflection');
      const particles = document.querySelector('.floating-particles');
      const sunnyEffects = document.querySelector('.sunny-effects');
      const floatingFlowers = document.querySelector('.floating-flowers');
      
      if (isNight) {
        // Show night elements
        if (stars) stars.style.opacity = '1';
        if (moon) moon.style.opacity = '0.18';
        if (moonlight) moonlight.style.opacity = '1';
        if (particles) particles.style.opacity = '1';
        if (sunnyEffects) sunnyEffects.style.opacity = '0';
        if (floatingFlowers) floatingFlowers.style.opacity = '0';
      } else {
        // Hide night elements for day mode
        if (stars) stars.style.opacity = '0.3';
        if (moon) moon.style.opacity = '0.05';
        if (moonlight) moonlight.style.opacity = '0.2';
        if (particles) particles.style.opacity = '0.5';
        if (sunnyEffects) sunnyEffects.style.opacity = '1';
        if (floatingFlowers) floatingFlowers.style.opacity = '1';
      }
    });

    socket.on('gameRestarted', () => {
      location.reload();
    });

    // Initialize host controls when the game starts
    socket.on('gameStarted', () => {
      initializeHostControls();
    });

    // Find the reset vote button handler and update it to only enable the vote button
    const resetVoteBtn = document.getElementById('resetVoteBtn');
    if (resetVoteBtn) {
      resetVoteBtn.addEventListener('click', () => {
        // Only enable the vote button
        const voteBtn = document.getElementById('voteSubmitBtn');
        if (voteBtn) {
          voteBtn.disabled = false;
          voteBtn.style.opacity = '1';
        }
        // Optionally show a message overlay if you want
        const overlay = document.getElementById('voteMessageOverlay');
        if (overlay) {
          overlay.style.display = 'block';
          setTimeout(() => {
            overlay.style.display = 'none';
            if (voteBtn) {
              voteBtn.disabled = true;
              voteBtn.style.opacity = '0.5';
            }
          }, 10000);
        }
      });
    }

    // --- Voice Chat Implementation ---
    
    class VoiceChat {
      constructor(roomId, playerName) {
        this.roomId = roomId;
        this.playerName = playerName;
        this.localStream = null;
        this.peerConnections = {};
        this.isMuted = true;
        this.isInitialized = false;
        this.audioContext = null;
        this.analyser = null;
        this.audioLevelInterval = null;
        this.joinStatus = 'waiting'; // waiting, queued, joining, connected
        
        this.init();
      }
      
      async init() {
        try {
          // Check if browser supports WebRTC
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('WebRTC not supported in this browser');
          }
          
          // Check if running on HTTPS (required for getUserMedia)
          if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
            throw new Error('Voice chat requires HTTPS (except on localhost)');
          }
          
          // Create UI first to show status
          this.createVoiceChatUI();
          this.updateStatus('Requesting microphone access...');
          
          // Get microphone access
          this.localStream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
              sampleRate: 48000,
              channelCount: 1
            }, 
            video: false 
          });
          
          // Create audio context for level monitoring
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          this.analyser = this.audioContext.createAnalyser();
          this.analyser.fftSize = 256;
          this.analyser.smoothingTimeConstant = 0.8;
          
          const source = this.audioContext.createMediaStreamSource(this.localStream);
          source.connect(this.analyser);
          
          this.updateStatus('Joining voice chat queue...');
          
          // Join voice chat (will be queued on server)
          socket.emit('voiceChat:join', { roomId: this.roomId, playerName: this.playerName });
          
          this.isInitialized = true;
          console.log('Voice chat initialized successfully');
          
          // Start audio level monitoring
          this.startAudioLevelMonitoring();
          
          // Start connection quality monitoring
          this.startConnectionQualityMonitoring();
          
          // Start participants list updates
          this.startParticipantsListUpdates();
          
        } catch (error) {
          console.error('Failed to initialize voice chat:', error);
          this.showMicrophoneError(error.message);
        }
      }
      
      startParticipantsListUpdates() {
        // Update participants list every 2 seconds to show connection status
        setInterval(() => {
          if (this.isInitialized) {
            socket.emit('voiceChat:getParticipants', { roomId: this.roomId });
          }
        }, 2000);
      }
      
      createVoiceChatUI() {
        console.log('[VoiceChat] Creating voice chat UI...');
        
        const voiceChatContainer = document.createElement('div');
        voiceChatContainer.className = 'voice-chat-container';
        voiceChatContainer.innerHTML = `
          <div class="voice-controls">
            <button id="muteButton" class="voice-btn mute" disabled>
              <i class="fas fa-microphone-slash"></i>
              <span class="btn-text">Muted</span>
            </button>
            <div class="audio-level" id="audioLevel">
              <div class="level-bar"></div>
            </div>
          </div>
          <div class="voice-status" id="voiceStatus">Initializing Voice Chat...</div>
          <div class="queue-status" id="queueStatus" style="display:none; font-size:11px; color:#666; margin-top:5px;"></div>
          <div class="participants-list" id="participantsList"></div>
        `;
        
        document.body.appendChild(voiceChatContainer);
        console.log('[VoiceChat] Voice chat UI created and added to DOM');
        
        const muteBtn = document.getElementById('muteButton');
        if (muteBtn) {
          console.log('[VoiceChat] Mute button found, adding click listener');
          muteBtn.addEventListener('click', () => {
            console.log('[VoiceChat] Mute button clicked!');
            this.toggleMute();
          });
        } else {
          console.error('[VoiceChat] Mute button not found!');
        }
        
        // Add Font Awesome for icons if not already present
        if (!document.querySelector('link[href*="font-awesome"]')) {
          const fontAwesome = document.createElement('link');
          fontAwesome.rel = 'stylesheet';
          fontAwesome.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css';
          document.head.appendChild(fontAwesome);
          console.log('[VoiceChat] Font Awesome added');
        }
        
        // Make sure the container is visible
        voiceChatContainer.style.display = 'block';
        voiceChatContainer.style.visibility = 'visible';
        voiceChatContainer.style.opacity = '1';
        
        console.log('[VoiceChat] Voice chat UI setup complete');
      }
      
      updateJoinStatus(status, data) {
        this.joinStatus = status;
        const queueStatusElement = document.getElementById('queueStatus');
        const muteBtn = document.getElementById('muteButton');
        
        switch (status) {
          case 'queued':
            this.updateStatus(`In queue: ${data.message}`);
            if (queueStatusElement) {
              queueStatusElement.textContent = `Position: ${data.position}`;
              queueStatusElement.style.display = 'block';
            }
            if (muteBtn) muteBtn.disabled = true;
            break;
            
          case 'joining':
            this.updateStatus(data.message);
            if (queueStatusElement) {
              queueStatusElement.textContent = 'Connecting...';
              queueStatusElement.style.display = 'block';
            }
            if (muteBtn) muteBtn.disabled = true;
            break;
            
          case 'connected':
            this.updateStatus('Voice Chat Ready');
            if (queueStatusElement) {
              queueStatusElement.style.display = 'none';
            }
            if (muteBtn) muteBtn.disabled = false;
            break;
        }
      }
      
      toggleMute() {
        console.log('[VoiceChat] toggleMute called, current state:', this.isMuted);
        
        this.isMuted = !this.isMuted;
        console.log('[VoiceChat] New mute state:', this.isMuted);
        
        // Update local stream
        if (this.localStream) {
          this.localStream.getTracks().forEach(track => {
            track.enabled = !this.isMuted;
            console.log('[VoiceChat] Audio track enabled:', !this.isMuted);
          });
        } else {
          console.warn('[VoiceChat] No local stream available');
        }
        
        // Update button appearance
        const muteBtn = document.getElementById('muteButton');
        if (muteBtn) {
          if (this.isMuted) {
            muteBtn.className = 'voice-btn mute';
            muteBtn.innerHTML = '<i class="fas fa-microphone-slash"></i><span class="btn-text">Muted</span>';
            console.log('[VoiceChat] Button updated to muted state');
          } else {
            muteBtn.className = 'voice-btn unmute';
            muteBtn.innerHTML = '<i class="fas fa-microphone"></i><span class="btn-text">Speaking</span>';
            console.log('[VoiceChat] Button updated to speaking state');
          }
        } else {
          console.error('[VoiceChat] Mute button not found for update');
        }
        
        // Notify server
        socket.emit('voiceChat:toggleMute', { 
          roomId: this.roomId, 
          playerName: this.playerName, 
          isMuted: this.isMuted 
        });
        console.log('[VoiceChat] Mute state sent to server');
        
        // Update status
        this.updateStatus(this.isMuted ? 'Muted' : 'Speaking');
      }
      
      startAudioLevelMonitoring() {
        if (!this.analyser) return;
        
        const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        
        this.audioLevelInterval = setInterval(() => {
          if (this.isMuted) return;
          
          this.analyser.getByteFrequencyData(dataArray);
          const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
          const level = Math.min(average / 128, 1); // Normalize to 0-1
          
          this.updateAudioLevel(level);
        }, 100);
      }
      
      startConnectionQualityMonitoring() {
        setInterval(() => {
          if (!this.peerConnections) return;
          
          Object.entries(this.peerConnections).forEach(([playerName, connection]) => {
            if (connection.connectionState === 'connected') {
              const stats = connection.getStats();
              stats.then(results => {
                results.forEach(report => {
                  if (report.type === 'inbound-rtp' && report.mediaType === 'audio') {
                    const packetLoss = report.packetsLost || 0;
                    const packetsReceived = report.packetsReceived || 0;
                    const lossRate = packetsReceived > 0 ? packetLoss / packetsReceived : 0;
                    
                    if (lossRate > 0.1) { // More than 10% packet loss
                      console.warn(`[VoiceChat] High packet loss for ${playerName}: ${(lossRate * 100).toFixed(1)}%`);
                      this.updateStatus(`Poor connection with ${playerName}`);
                    }
                  }
                });
              });
            }
          });
        }, 5000); // Check every 5 seconds
      }
      
      updateAudioLevel(level) {
        const levelBar = document.querySelector('.level-bar');
        if (levelBar) {
          levelBar.style.height = `${level * 100}%`;
          levelBar.style.backgroundColor = level > 0.5 ? '#28a745' : '#6c757d';
        }
      }
      
      updateStatus(status) {
        const statusElement = document.getElementById('voiceStatus');
        if (statusElement) {
          statusElement.textContent = status;
        }
      }
      
      updateParticipantsList(participants) {
        const listElement = document.getElementById('participantsList');
        if (listElement) {
          listElement.innerHTML = participants.map(name => 
            `<div class="participant ${name === this.playerName ? 'me' : ''}">
              <i class="fas fa-user"></i>
              <span>${name}</span>
              ${name === this.playerName ? '<span class="mute-indicator">(You)</span>' : ''}
              ${this.getConnectionStatus(name)}
            </div>`
          ).join('');
        }
      }
      
      getConnectionStatus(playerName) {
        if (playerName === this.playerName) return '';
        
        const connection = this.peerConnections[playerName];
        if (!connection) return '<span class="connection-status connecting">Connecting...</span>';
        
        switch (connection.connectionState) {
          case 'connected':
            return '<span class="connection-status connected"><i class="fas fa-circle"></i></span>';
          case 'connecting':
            return '<span class="connection-status connecting"><i class="fas fa-spinner fa-spin"></i></span>';
          case 'disconnected':
            return '<span class="connection-status disconnected"><i class="fas fa-circle"></i></span>';
          case 'failed':
            return '<span class="connection-status failed"><i class="fas fa-exclamation-triangle"></i></span>';
          default:
            return '<span class="connection-status unknown"><i class="fas fa-question-circle"></i></span>';
        }
      }
      
      async createPeerConnection(targetPlayer) {
        try {
          const peerConnection = new RTCPeerConnection({
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
              { urls: 'stun:stun2.l.google.com:19302' },
              { urls: 'stun:stun3.l.google.com:19302' },
              { urls: 'stun:stun4.l.google.com:19302' }
            ],
            iceCandidatePoolSize: 10,
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require'
          });
          
          // Add local stream
          if (this.localStream) {
            this.localStream.getTracks().forEach(track => {
              peerConnection.addTrack(track, this.localStream);
            });
          }
          
          // Handle incoming audio
          peerConnection.ontrack = (event) => {
            console.log('[VoiceChat] Received audio track from:', targetPlayer);
            const audioElement = this.getOrCreateAudioElement(targetPlayer);
            audioElement.srcObject = event.streams[0];
            audioElement.play().catch(e => console.log('Auto-play prevented:', e));
          };
          
          // ICE candidate handling
          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              socket.emit('voiceChat:iceCandidate', {
                roomId: this.roomId,
                targetPlayer: targetPlayer,
                candidate: event.candidate
              });
            }
          };
          
          // Connection state changes
          peerConnection.onconnectionstatechange = () => {
            console.log('[VoiceChat] Connection state changed for', targetPlayer, ':', peerConnection.connectionState);
            
            switch (peerConnection.connectionState) {
              case 'connected':
                this.updateStatus(`Connected to ${targetPlayer}`);
                break;
              case 'disconnected':
                this.updateStatus(`Disconnected from ${targetPlayer}`);
                break;
              case 'failed':
                console.log('[VoiceChat] Connection failed, retrying...');
                this.retryConnection(targetPlayer);
                break;
              case 'closed':
                console.log('[VoiceChat] Connection closed for', targetPlayer);
                break;
            }
          };
          
          // ICE connection state changes
          peerConnection.oniceconnectionstatechange = () => {
            console.log('[VoiceChat] ICE connection state for', targetPlayer, ':', peerConnection.iceConnectionState);
            
            if (peerConnection.iceConnectionState === 'failed') {
              console.log('[VoiceChat] ICE connection failed, retrying...');
              this.retryConnection(targetPlayer);
            }
          };
          
          // ICE gathering state changes
          peerConnection.onicegatheringstatechange = () => {
            console.log('[VoiceChat] ICE gathering state for', targetPlayer, ':', peerConnection.iceGatheringState);
          };
          
          this.peerConnections[targetPlayer] = peerConnection;
          
          // Create and send offer with timeout
          const offerPromise = peerConnection.createOffer();
          const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Offer creation timeout')), 10000)
          );
          
          const offer = await Promise.race([offerPromise, timeoutPromise]);
          await peerConnection.setLocalDescription(offer);
          
          socket.emit('voiceChat:offer', {
            roomId: this.roomId,
            targetPlayer: targetPlayer,
            offer: offer
          });
          
          return peerConnection;
        } catch (error) {
          console.error('[VoiceChat] Failed to create peer connection:', error);
          this.updateStatus(`Failed to connect to ${targetPlayer}`);
          
          // Retry after a delay
          setTimeout(() => {
            if (!this.peerConnections[targetPlayer]) {
              this.createPeerConnection(targetPlayer);
            }
          }, 3000);
        }
      }
      
      async retryConnection(targetPlayer) {
        if (this.peerConnections[targetPlayer]) {
          this.peerConnections[targetPlayer].close();
          delete this.peerConnections[targetPlayer];
        }
        
        setTimeout(() => {
          this.createPeerConnection(targetPlayer);
        }, 1000);
      }
      
      getOrCreateAudioElement(playerName) {
        let audioElement = document.getElementById(`audio-${playerName}`);
        if (!audioElement) {
          audioElement = document.createElement('audio');
          audioElement.id = `audio-${playerName}`;
          audioElement.autoplay = true;
          audioElement.volume = 0.7;
          audioElement.style.display = 'none';
          document.body.appendChild(audioElement);
        }
        return audioElement;
      }
      
      showMicrophoneError(message) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'voice-error';
        errorDiv.innerHTML = `
          <div class="error-message">
            <i class="fas fa-exclamation-triangle"></i>
            <span>${message || 'Microphone access denied. Voice chat unavailable.'}</span>
            <button onclick="this.parentElement.parentElement.remove()" class="error-close">
              <i class="fas fa-times"></i>
            </button>
          </div>
        `;
        document.body.appendChild(errorDiv);
        
        // Auto-remove after 10 seconds
        setTimeout(() => {
          if (errorDiv.parentElement) {
            errorDiv.remove();
          }
        }, 10000);
      }
      
      cleanup() {
        console.log('[VoiceChat] Cleaning up voice chat...');
        
        // Stop audio level monitoring
        if (this.audioLevelInterval) {
          clearInterval(this.audioLevelInterval);
        }
        
        // Stop connection quality monitoring
        if (this.connectionQualityInterval) {
          clearInterval(this.connectionQualityInterval);
        }
        
        // Stop participants list updates
        if (this.participantsUpdateInterval) {
          clearInterval(this.participantsUpdateInterval);
        }
        
        // Stop local stream
        if (this.localStream) {
          this.localStream.getTracks().forEach(track => track.stop());
        }
        
        // Close audio context
        if (this.audioContext && this.audioContext.state !== 'closed') {
          this.audioContext.close();
        }
        
        // Close peer connections
        Object.values(this.peerConnections).forEach(pc => {
          if (pc && pc.connectionState !== 'closed') {
            pc.close();
          }
        });
        
        // Remove audio elements
        document.querySelectorAll('[id^="audio-"]').forEach(el => el.remove());
        
        // Remove UI
        const voiceChatContainer = document.querySelector('.voice-chat-container');
        if (voiceChatContainer) {
          voiceChatContainer.remove();
        }
        
        // Remove error messages
        document.querySelectorAll('.voice-error').forEach(el => el.remove());
        
        // Notify server
        socket.emit('voiceChat:leave', { roomId: this.roomId, playerName: this.playerName });
        
        // Reset state
        this.isInitialized = false;
        this.peerConnections = {};
        
        console.log('[VoiceChat] Cleanup complete');
      }
    }

    // Voice chat instance
    let voiceChat = null;

    // Initialize voice chat immediately for testing (you can remove this later)
    function initializeVoiceChatNow() {
      if (!voiceChat && roomId && myName) {
        console.log('[VoiceChat] Initializing voice chat immediately...');
        voiceChat = new VoiceChat(roomId, myName);
      }
    }

    // Add a manual trigger button for testing (you can remove this later)
    function addVoiceChatTestButton() {
      const testButton = document.createElement('button');
      testButton.textContent = 'üé§ Enable Voice Chat';
      testButton.id = 'enableVoiceChatBtn';
      testButton.style.cssText = `
        position: fixed;
        top: 80px;
        right: 32px;
        z-index: 1000;
        padding: 12px 28px;
        background: linear-gradient(120deg, #fffbe7 60%, #ffe7b2 100%);
        color: #e2a84f;
        border: 2.5px solid #ffdca8;
        border-radius: 16px;
        font-family: 'Gochi Hand', 'Segoe Print', cursive;
        font-size: 1.08em;
        font-weight: bold;
        box-shadow: 0 2px 8px 0 #ffdca833, 0 0 0 1px rgba(255,255,255,0.1) inset;
        cursor: pointer;
        letter-spacing: 1px;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        transition: all 0.3s ease;
        margin-top: 16px;
      `;
      testButton.onmouseenter = () => {
        testButton.style.boxShadow = '0 8px 20px 0 #ffdca866, 0 0 0 1px rgba(255,255,255,0.2) inset, 0 0 30px rgba(255,220,168,0.4)';
        testButton.style.transform = 'translateY(-3px)';
      };
      testButton.onmouseleave = () => {
        testButton.style.boxShadow = '0 2px 8px 0 #ffdca833, 0 0 0 1px rgba(255,255,255,0.1) inset';
        testButton.style.transform = 'none';
      };
      testButton.onclick = initializeVoiceChatNow;
      document.body.appendChild(testButton);
    }

    // Initialize voice chat when game starts
    socket.on('startGame', ({ gameState }) => {
      // Initialize voice chat after game starts
      setTimeout(() => {
        if (!voiceChat) {
          voiceChat = new VoiceChat(roomId, myName);
        }
      }, 1000);
    });

    // Add test button immediately for testing
    setTimeout(() => {
      addVoiceChatTestButton();
    }, 2000);

    // Cleanup on disconnect
    window.addEventListener('beforeunload', () => {
      if (voiceChat) {
        voiceChat.cleanup();
      }
    });

    // Handle voice chat events
    socket.on('voiceChat:playerJoined', ({ playerName }) => {
      console.log('[VoiceChat] Player joined:', playerName);
      if (voiceChat && playerName !== myName) {
        voiceChat.createPeerConnection(playerName);
      }
    });

    socket.on('voiceChat:joinStatus', ({ status, position, message }) => {
      console.log('[VoiceChat] Join status update:', { status, position, message });
      if (voiceChat) {
        voiceChat.updateJoinStatus(status, { position, message });
      }
    });

    socket.on('voiceChat:playerLeft', ({ playerName }) => {
      console.log('[VoiceChat] Player left:', playerName);
      if (voiceChat) {
        // Remove audio element
        const audioElement = document.getElementById(`audio-${playerName}`);
        if (audioElement) {
          audioElement.remove();
        }
        
        // Close connection
        if (voiceChat.peerConnections[playerName]) {
          voiceChat.peerConnections[playerName].close();
          delete voiceChat.peerConnections[playerName];
        }
      }
    });

    socket.on('voiceChat:playerMuteChanged', ({ playerName, isMuted }) => {
      console.log('[VoiceChat] Player mute changed:', playerName, isMuted);
      // Update UI to show mute status for other players
      if (voiceChat) {
        voiceChat.updateStatus(`${playerName} ${isMuted ? 'muted' : 'unmuted'}`);
      }
    });

    socket.on('voiceChat:participantsList', ({ participants }) => {
      console.log('[VoiceChat] Participants list:', participants);
      if (voiceChat) {
        voiceChat.updateParticipantsList(participants);
        
        // Mark as connected and enable mute button
        voiceChat.updateJoinStatus('connected', {});
        
        // Create connections for existing participants
        participants.forEach(participantName => {
          if (participantName !== myName && !voiceChat.peerConnections[participantName]) {
            voiceChat.createPeerConnection(participantName);
          }
        });
      }
    });

    // WebRTC signaling events
    socket.on('voiceChat:offer', async ({ from, offer, roomId }) => {
      console.log('[VoiceChat] Received offer from:', from);
      if (voiceChat && roomId === voiceChat.roomId) {
        try {
          const peerConnection = new RTCPeerConnection({
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
              { urls: 'stun:stun2.l.google.com:19302' },
              { urls: 'stun:stun3.l.google.com:19302' },
              { urls: 'stun:stun4.l.google.com:19302' }
            ]
          });
          
          // Add local stream
          if (voiceChat.localStream) {
            voiceChat.localStream.getTracks().forEach(track => {
              peerConnection.addTrack(track, voiceChat.localStream);
            });
          }
          
          // Handle incoming audio
          peerConnection.ontrack = (event) => {
            const audioElement = voiceChat.getOrCreateAudioElement(from);
            audioElement.srcObject = event.streams[0];
            audioElement.play().catch(e => console.log('Auto-play prevented:', e));
          };
          
          // ICE candidate handling
          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              socket.emit('voiceChat:iceCandidate', {
                roomId: voiceChat.roomId,
                targetPlayer: from,
                candidate: event.candidate
              });
            }
          };
          
          voiceChat.peerConnections[from] = peerConnection;
          
          // Set remote description and create answer
          await peerConnection.setRemoteDescription(offer);
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          
          socket.emit('voiceChat:answer', {
            roomId: voiceChat.roomId,
            targetPlayer: from,
            answer: answer
          });
        } catch (error) {
          console.error('[VoiceChat] Failed to handle offer:', error);
        }
      }
    });

    socket.on('voiceChat:answer', async ({ from, answer, roomId }) => {
      console.log('[VoiceChat] Received answer from:', from);
      if (voiceChat && roomId === voiceChat.roomId && voiceChat.peerConnections[from]) {
        try {
          await voiceChat.peerConnections[from].setRemoteDescription(answer);
        } catch (error) {
          console.error('[VoiceChat] Failed to set remote description:', error);
        }
      }
    });

    socket.on('voiceChat:iceCandidate', async ({ from, candidate, roomId }) => {
      if (voiceChat && roomId === voiceChat.roomId && voiceChat.peerConnections[from]) {
        try {
          await voiceChat.peerConnections[from].addIceCandidate(candidate);
        } catch (error) {
          console.error('[VoiceChat] Failed to add ICE candidate:', error);
        }
      }
    });

    // After receiving initialGameState or gameStateUpdate, start a timer to check for missing role
    let roleCheckTimer = null;
    function checkRoleAssigned() {
      if (!gameState || !gameState.players) return;
      const me = gameState.players.find(p => p.id === socket.id);
      if (!me || !me.role || me.role === 'backSide') {
        alert('Connection issue: Please refresh or rejoin the room.');
      }
    }
    socket.on('initialGameState', (state) => {
      gameState = state;
      // ... existing code ...
      if (roleCheckTimer) clearTimeout(roleCheckTimer);
      roleCheckTimer = setTimeout(checkRoleAssigned, 5000);
    });
    socket.on('gameStateUpdate', (state) => {
      gameState = state;
      // ... existing code ...
      if (roleCheckTimer) clearTimeout(roleCheckTimer);
      roleCheckTimer = setTimeout(checkRoleAssigned, 5000);
    });

    // Toggle between day and night modes
    function toggleStage() {
      const body = document.body;
      const toggleBtn = document.getElementById('toggleStageBtn');
      
      if (body.classList.contains('night-mode')) {
        // Switch from night to day mode
        body.classList.remove('night-mode');
        body.classList.add('day-mode');
        toggleBtn.innerHTML = 'üåô Switch to Night';
      } else {
        // Switch from day to night mode
        body.classList.remove('day-mode');
        body.classList.add('night-mode');
        toggleBtn.innerHTML = '‚òÄÔ∏è Switch to Day';
      }
    }

    // Initialize the page
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize day/night mode toggle
      const toggleBtn = document.getElementById('toggleStageBtn');
      const body = document.body;
      
      // Set initial button state based on current mode
      if (body.classList.contains('night-mode')) {
        toggleBtn.innerHTML = '‚òÄÔ∏è Switch to Day';
      } else {
        toggleBtn.innerHTML = 'üåô Switch to Night';
      }
      
      // Add event listener for toggle button
      toggleBtn.addEventListener('click', toggleStage);
      
      // Initialize other elements
      initializeStars();
      initializeSunRays();
      initializeFlowers();
      initializeParticles();
      initializeMoon();
      initializeMoonlightReflection();
      
      // ... existing code ...
    });

    // Initialize background elements
    function initializeStars() {
      const starsContainer = document.querySelector('.ghibli-stars');
      if (!starsContainer) return;
      
      for (let i = 0; i < 50; i++) {
        const star = document.createElement('span');
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        star.style.width = Math.random() * 3 + 2 + 'px';
        star.style.height = star.style.width;
        star.style.animationDelay = Math.random() * 4 + 's';
        starsContainer.appendChild(star);
      }
    }

    function initializeSunRays() {
      const sunContainer = document.querySelector('.sun-rays');
      if (!sunContainer) return;
      
      for (let i = 0; i < 12; i++) {
        const ray = document.createElement('div');
        ray.className = 'sun-ray';
        ray.style.transform = `translate(-50%, -50%) rotate(${i * 30}deg)`;
        ray.style.animationDelay = Math.random() * 2 + 's';
        sunContainer.appendChild(ray);
      }
    }

    function initializeFlowers() {
      const flowersContainer = document.querySelector('.floating-flowers');
      if (!flowersContainer) return;
      
      for (let i = 0; i < 15; i++) {
        const flower = document.createElement('div');
        flower.className = 'flower';
        flower.style.left = Math.random() * 100 + '%';
        flower.style.animationDelay = Math.random() * 18 + 's';
        flower.style.animationDuration = (Math.random() * 10 + 15) + 's';
        flowersContainer.appendChild(flower);
      }
    }

    function initializeParticles() {
      const particlesContainer = document.querySelector('.floating-particles');
      if (!particlesContainer) return;
      
      for (let i = 0; i < 30; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = Math.random() * 100 + '%';
        particle.style.animationDelay = Math.random() * 25 + 's';
        particle.style.animationDuration = (Math.random() * 15 + 20) + 's';
        particlesContainer.appendChild(particle);
      }
    }

    function initializeMoon() {
      const moon = document.querySelector('.ghibli-moon');
      if (!moon) return;
      
      // Moon is already in HTML, just ensure it's visible
      moon.style.display = 'block';
    }

    function initializeMoonlightReflection() {
      const reflection = document.querySelector('.moonlight-reflection');
      if (!reflection) return;
      
      // Reflection is already in HTML, just ensure it's visible
      reflection.style.display = 'block';
    }

    // Example: Render Ghibli-style voice chat status box (replace your current status UI with this)
    function renderVoiceChatStatusBox(isMuted, participants) {
      let box = document.getElementById('voiceChatStatusBox');
      if (!box) {
        box = document.createElement('div');
        box.id = 'voiceChatStatusBox';
        box.className = 'voice-chat-status-box';
        document.body.appendChild(box);
      }
      box.innerHTML = `
        <div class="voice-chat-status-title"><span class="emoji">üé§</span> Voice Chat Ready</div>
        <button class="voice-mute-toggle${isMuted ? ' muted' : ''}" id="voiceMuteToggleBtn">
          <span class="emoji">${isMuted ? 'üîá' : 'üîä'}</span> ${isMuted ? 'Muted' : 'Speak'}
        </button>
        <div style="margin-top:6px;">${participants.map(p => `<div class='voice-chat-participant'>üë§ ${p}</div>`).join('')}</div>
      `;
      document.getElementById('voiceMuteToggleBtn').onclick = function() {
        // Toggle mute logic here
        // ...
      };
    }

    // Always join the room on page load, whether host or not
    socket.emit('joinRoom', { roomId, playerName: myName }, (res) => {
      if (!res.success) {
        alert(res.message || 'Failed to join room.');
        window.location.href = 'joining.html';
      }
    });

    const testPlayers = [
      'Test Player 1',
      'Test Player 2',
      'Test Player 3',
      'Test Player 4',
      'Test Player 5'
    ];

    // Add CSS for host helper mode
    const hostHelperStyle = document.createElement('style');
    hostHelperStyle.textContent = `
      .host-helper-mode .player-card {
        cursor: pointer;
        transition: transform 0.3s, box-shadow 0.3s;
      }
      .host-helper-mode .player-card:hover {
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(226, 195, 145, 0.4);
      }
      .player-card.selected-host {
        border: 4px solid #4caf50;
        box-shadow: 0 0 20px rgba(76, 175, 80, 0.4);
      }
      .ghibli-notification {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #fffbe7;
        border: 2px solid #e2c391;
        border-radius: 12px;
        padding: 15px 25px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        z-index: 1000;
        font-family: 'Segoe Print', 'Comic Sans MS', cursive;
        color: #5a4327;
        animation: notification-slide 0.5s ease-out;
      }
      @keyframes notification-slide {
        from {
          transform: translateX(-50%) translateY(-100%);
          opacity: 0;
        }
        to {
          transform: translateX(-50%) translateY(0);
          opacity: 1;
        }
      }
    `;
    document.head.appendChild(hostHelperStyle);

    // Host helper mode variables
    let isHostHelperMode = false;
    let selectedHosts = new Set();

    // Toggle host helper mode
    function toggleHostHelper() {
      isHostHelperMode = !isHostHelperMode;
      const gameArea = document.querySelector('.game-area');
      const hostHelperBtn = document.getElementById('hostHelperBtn');
      
      if (isHostHelperMode) {
        gameArea.classList.add('host-helper-mode');
        hostHelperBtn.style.background = '#4caf50';
        showGhibliNotification('Click on players to select Family Party hosts!');
        
        // Add click handlers to player cards
        const playerCards = document.querySelectorAll('.player-card');
        playerCards.forEach(card => {
          card.onclick = function() {
            if (card.classList.contains('selected-host')) {
              card.classList.remove('selected-host');
              selectedHosts.delete(card.getAttribute('data-player'));
            } else {
              card.classList.add('selected-host');
              selectedHosts.add(card.getAttribute('data-player'));
            }
          };
        });
      } else {
        gameArea.classList.remove('host-helper-mode');
        hostHelperBtn.style.background = '';
        showGhibliNotification('Family Party hosts have been selected!');
        
        // Remove click handlers from player cards
        const playerCards = document.querySelectorAll('.player-card');
        playerCards.forEach(card => {
          card.onclick = null;
        });
        
        // Emit selected hosts to server
        socket.emit('updatePartyHosts', { roomId, hosts: Array.from(selectedHosts) });
      }
    }

    // Show Ghibli-style notification
    function showGhibliNotification(message, duration = 3000) {
      const notification = document.createElement('div');
      notification.className = 'ghibli-notification';
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.transform = 'translateX(-50%) translateY(-100%)';
        setTimeout(() => notification.remove(), 500);
      }, duration);
    }

    // Update love/hate button states based on party hosts
    socket.on('partyHostsUpdate', ({ hosts }) => {
      const loveBtn = document.getElementById('loveBtn');
      const hateBtn = document.getElementById('hateBtn');
      
      if (hosts.includes(myName)) {
        loveBtn.disabled = false;
        hateBtn.disabled = false;
      } else {
        loveBtn.disabled = true;
        hateBtn.disabled = true;
      }
    });

    // Function to reset party hosts
    function resetPartyHosts() {
      if (!isHost) return;
      
      // Clear selected hosts
      selectedHosts.clear();
      
      // Reset visual state
      document.querySelectorAll('.player-card').forEach(card => {
        card.classList.remove('selected-host');
      });
      document.querySelectorAll('.party-host-indicator, .party-host-crown').forEach(el => el.remove());
      
      // Reset button state if in host helper mode
      const hostHelperBtn = document.getElementById('hostHelperBtn');
      if (isHostHelperMode) {
        isHostHelperMode = false;
        hostHelperBtn.style.background = '';
        document.querySelector('.game-area').classList.remove('host-helper-mode');
      }
      
      // Emit empty hosts array to server
      socket.emit('updatePartyHosts', { roomId, hosts: [] });
      
      // Show notification
      showGhibliNotification('Party hosts have been reset!');
    }
  </script>
</body>
</html>
